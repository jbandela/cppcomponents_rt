<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html">SplitListMap< cds::urcu::gc< RCU >, Key, Value, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Split-ordered list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/split_list_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.png" usemap="#cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map" alt=""/>
  <map id="cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map" name="cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map">
<area href="classcds_1_1container_1_1_split_list_set.html" alt="cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;" shape="rect" coords="0,56,1013,80"/>
<area href="classcds_1_1intrusive_1_1_split_list_set.html" alt="cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;" shape="rect" coords="0,0,1013,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a34004c6efc0bf6163bfc0838a81d6af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34004c6efc0bf6163bfc0838a81d6af3"></a>
typedef base_class::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a34004c6efc0bf6163bfc0838a81d6af3">gc</a></td></tr>
<tr class="memdesc:a34004c6efc0bf6163bfc0838a81d6af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:a34004c6efc0bf6163bfc0838a81d6af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e25dd8f881eb1af7bf624a64330ab18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e25dd8f881eb1af7bf624a64330ab18"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a></td></tr>
<tr class="memdesc:a9e25dd8f881eb1af7bf624a64330ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br/></td></tr>
<tr class="separator:a9e25dd8f881eb1af7bf624a64330ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1fdbb6c05b121221d300031c7ac19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99d1fdbb6c05b121221d300031c7ac19"></a>
typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a></td></tr>
<tr class="memdesc:a99d1fdbb6c05b121221d300031c7ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the map <br/></td></tr>
<tr class="separator:a99d1fdbb6c05b121221d300031c7ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682405bbab11f0cd0287f763ac14f5a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682405bbab11f0cd0287f763ac14f5a5"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> <br class="typebreak"/>
const, <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a></td></tr>
<tr class="memdesc:a682405bbab11f0cd0287f763ac14f5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">key-value pair type <br/></td></tr>
<tr class="separator:a682405bbab11f0cd0287f763ac14f5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e33ceb9acfeec3ae22f3e54075bf40"></a>
typedef base_class::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad4e33ceb9acfeec3ae22f3e54075bf40">ordered_list</a></td></tr>
<tr class="memdesc:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br/></td></tr>
<tr class="separator:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bbdea9db64a3c1b833c13e8507dc2ee"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7bbdea9db64a3c1b833c13e8507dc2ee">key_comparator</a></td></tr>
<tr class="memdesc:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparision functor <br/></td></tr>
<tr class="separator:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f287833bda6211df83817d566d526d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f287833bda6211df83817d566d526d"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad3f287833bda6211df83817d566d526d">hash</a></td></tr>
<tr class="memdesc:ad3f287833bda6211df83817d566d526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a>. <br/></td></tr>
<tr class="separator:ad3f287833bda6211df83817d566d526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170d9bb565f6fb4441bd76131d61130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6170d9bb565f6fb4441bd76131d61130"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6170d9bb565f6fb4441bd76131d61130">item_counter</a></td></tr>
<tr class="memdesc:a6170d9bb565f6fb4441bd76131d61130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br/></td></tr>
<tr class="separator:a6170d9bb565f6fb4441bd76131d61130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b81aead03e9460711e566824a2713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa91b81aead03e9460711e566824a2713"></a>
typedef base_class::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a></td></tr>
<tr class="memdesc:aa91b81aead03e9460711e566824a2713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br/></td></tr>
<tr class="separator:aa91b81aead03e9460711e566824a2713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9039192cd438d5b60e8583d510f79e9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9039192cd438d5b60e8583d510f79e9f"></a>
typedef base_class::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a></td></tr>
<tr class="memdesc:a9039192cd438d5b60e8583d510f79e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br/></td></tr>
<tr class="separator:a9039192cd438d5b60e8583d510f79e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e9a7ffed701fe108e98e27790782042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a> ()</td></tr>
<tr class="memdesc:a2e9a7ffed701fe108e98e27790782042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map.  <a href="#a2e9a7ffed701fe108e98e27790782042">More...</a><br/></td></tr>
<tr class="separator:a2e9a7ffed701fe108e98e27790782042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9411b38419a5dc5ce92ba48f48339e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a> ()</td></tr>
<tr class="memdesc:a9411b38419a5dc5ce92ba48f48339e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a map.  <a href="#a9411b38419a5dc5ce92ba48f48339e52">More...</a><br/></td></tr>
<tr class="separator:a9411b38419a5dc5ce92ba48f48339e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0392614ddcd0ada7bb78136dc97bbc85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a0392614ddcd0ada7bb78136dc97bbc85">SplitListMap</a> ()</td></tr>
<tr class="memdesc:a0392614ddcd0ada7bb78136dc97bbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered map of default capacity.  <a href="#a0392614ddcd0ada7bb78136dc97bbc85">More...</a><br/></td></tr>
<tr class="separator:a0392614ddcd0ada7bb78136dc97bbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a4bcf30da24623b50f97a1f5e49e2bc55">SplitListMap</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered map.  <a href="#a4bcf30da24623b50f97a1f5e49e2bc55">More...</a><br/></td></tr>
<tr class="separator:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732e42943b07d8e216d25c42def7f01"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a9732e42943b07d8e216d25c42def7f01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9732e42943b07d8e216d25c42def7f01">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a9732e42943b07d8e216d25c42def7f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a9732e42943b07d8e216d25c42def7f01">More...</a><br/></td></tr>
<tr class="separator:a9732e42943b07d8e216d25c42def7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1da831a875c8ef38964f7a63d68fb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a37e1da831a875c8ef38964f7a63d68fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a37e1da831a875c8ef38964f7a63d68fb">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a37e1da831a875c8ef38964f7a63d68fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a37e1da831a875c8ef38964f7a63d68fb">More...</a><br/></td></tr>
<tr class="separator:a37e1da831a875c8ef38964f7a63d68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06630bb49b75d1a4c6768b5f10296f5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ae06630bb49b75d1a4c6768b5f10296f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ae06630bb49b75d1a4c6768b5f10296f5">insert_key</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:ae06630bb49b75d1a4c6768b5f10296f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#ae06630bb49b75d1a4c6768b5f10296f5">More...</a><br/></td></tr>
<tr class="separator:ae06630bb49b75d1a4c6768b5f10296f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7d84aee09c4327f325c43a43548600"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a9c7d84aee09c4327f325c43a43548600"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9c7d84aee09c4327f325c43a43548600">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9c7d84aee09c4327f325c43a43548600"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a9c7d84aee09c4327f325c43a43548600">More...</a><br/></td></tr>
<tr class="separator:a9c7d84aee09c4327f325c43a43548600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031c0a51dd45f45e0bf691ca339f9358"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a031c0a51dd45f45e0bf691ca339f9358"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a031c0a51dd45f45e0bf691ca339f9358">ensure</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a031c0a51dd45f45e0bf691ca339f9358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>key</code> exists in the map.  <a href="#a031c0a51dd45f45e0bf691ca339f9358">More...</a><br/></td></tr>
<tr class="separator:a031c0a51dd45f45e0bf691ca339f9358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb1f2b166d2b12f9f2a84344e264003"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aebb1f2b166d2b12f9f2a84344e264003"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aebb1f2b166d2b12f9f2a84344e264003">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:aebb1f2b166d2b12f9f2a84344e264003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#aebb1f2b166d2b12f9f2a84344e264003">More...</a><br/></td></tr>
<tr class="separator:aebb1f2b166d2b12f9f2a84344e264003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6e6674c5f0b6b4f0f523fcd4cba878c0">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a6e6674c5f0b6b4f0f523fcd4cba878c0">More...</a><br/></td></tr>
<tr class="separator:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a4e0d10489ab3ad0da3fd7ed9aa32e994">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#a4e0d10489ab3ad0da3fd7ed9aa32e994">More...</a><br/></td></tr>
<tr class="separator:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93282b6aba0332c6fce60c3fedf23115"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a93282b6aba0332c6fce60c3fedf23115"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a93282b6aba0332c6fce60c3fedf23115">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a93282b6aba0332c6fce60c3fedf23115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a93282b6aba0332c6fce60c3fedf23115">More...</a><br/></td></tr>
<tr class="separator:a93282b6aba0332c6fce60c3fedf23115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b497490353d85557018c5b908f82f0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab1b497490353d85557018c5b908f82f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ab1b497490353d85557018c5b908f82f0">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ab1b497490353d85557018c5b908f82f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#ab1b497490353d85557018c5b908f82f0">More...</a><br/></td></tr>
<tr class="separator:ab1b497490353d85557018c5b908f82f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad593abbddb349e7e7d5642269f70d0cd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ad593abbddb349e7e7d5642269f70d0cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad593abbddb349e7e7d5642269f70d0cd">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ad593abbddb349e7e7d5642269f70d0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#ad593abbddb349e7e7d5642269f70d0cd">More...</a><br/></td></tr>
<tr class="separator:ad593abbddb349e7e7d5642269f70d0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06e21259a38fb015db22d81348a510"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a6f06e21259a38fb015db22d81348a510"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6f06e21259a38fb015db22d81348a510">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a6f06e21259a38fb015db22d81348a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a6f06e21259a38fb015db22d81348a510">More...</a><br/></td></tr>
<tr class="separator:a6f06e21259a38fb015db22d81348a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7492e25910ec4403e15669d785c8b7bf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a7492e25910ec4403e15669d785c8b7bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7492e25910ec4403e15669d785c8b7bf">find_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a7492e25910ec4403e15669d785c8b7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a7492e25910ec4403e15669d785c8b7bf">More...</a><br/></td></tr>
<tr class="separator:a7492e25910ec4403e15669d785c8b7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bba93ee1391b60e4155702a3f32fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a22bba93ee1391b60e4155702a3f32fbf">clear</a> ()</td></tr>
<tr class="memdesc:a22bba93ee1391b60e4155702a3f32fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (non-atomic)  <a href="#a22bba93ee1391b60e4155702a3f32fbf">More...</a><br/></td></tr>
<tr class="separator:a22bba93ee1391b60e4155702a3f32fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524158157038188845708bc6058b630f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a524158157038188845708bc6058b630f">empty</a> () const </td></tr>
<tr class="memdesc:a524158157038188845708bc6058b630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a524158157038188845708bc6058b630f">More...</a><br/></td></tr>
<tr class="separator:a524158157038188845708bc6058b630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25c58f3c6aff8c4750893a0e9e7e142"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25c58f3c6aff8c4750893a0e9e7e142"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ac25c58f3c6aff8c4750893a0e9e7e142">size</a> () const </td></tr>
<tr class="memdesc:ac25c58f3c6aff8c4750893a0e9e7e142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br/></td></tr>
<tr class="separator:ac25c58f3c6aff8c4750893a0e9e7e142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a59ca6c0583eb55382220eeefc22fd569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59ca6c0583eb55382220eeefc22fd569"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a59ca6c0583eb55382220eeefc22fd569">begin</a> () const </td></tr>
<tr class="memdesc:a59ca6c0583eb55382220eeefc22fd569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br/></td></tr>
<tr class="separator:a59ca6c0583eb55382220eeefc22fd569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676fa0fa36ddff36c00165146c445586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a676fa0fa36ddff36c00165146c445586"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> ()</td></tr>
<tr class="separator:a676fa0fa36ddff36c00165146c445586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7c887c4f2cbc89fd5e7cc40f0f08b2b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c887c4f2cbc89fd5e7cc40f0f08b2b7"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7c887c4f2cbc89fd5e7cc40f0f08b2b7">end</a> () const </td></tr>
<tr class="memdesc:a7c887c4f2cbc89fd5e7cc40f0f08b2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br/></td></tr>
<tr class="separator:a7c887c4f2cbc89fd5e7cc40f0f08b2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c7b593bb99fe0950c46f582e1b7b22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c7b593bb99fe0950c46f582e1b7b22"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> ()</td></tr>
<tr class="separator:a37c7b593bb99fe0950c46f582e1b7b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a47d871acf86337963b147779cbc58606 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47d871acf86337963b147779cbc58606"></a>
typedef options::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a47d871acf86337963b147779cbc58606">gc</a></td></tr>
<tr class="memdesc:a47d871acf86337963b147779cbc58606 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:a47d871acf86337963b147779cbc58606 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c185bd2691ad2537d86201b23c5e11 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1c185bd2691ad2537d86201b23c5e11"></a>
typedef options::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1c185bd2691ad2537d86201b23c5e11">value_type</a></td></tr>
<tr class="memdesc:ab1c185bd2691ad2537d86201b23c5e11 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the list <br/></td></tr>
<tr class="separator:ab1c185bd2691ad2537d86201b23c5e11 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e50e02b49d3f187c70049961a51adc inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11e50e02b49d3f187c70049961a51adc"></a>
typedef options::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a11e50e02b49d3f187c70049961a51adc">ordered_list</a></td></tr>
<tr class="memdesc:a11e50e02b49d3f187c70049961a51adc inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br/></td></tr>
<tr class="separator:a11e50e02b49d3f187c70049961a51adc inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5497c22d61d56489cbca457a5e7f047 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5497c22d61d56489cbca457a5e7f047"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#af5497c22d61d56489cbca457a5e7f047">key_comparator</a></td></tr>
<tr class="memdesc:af5497c22d61d56489cbca457a5e7f047 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br/></td></tr>
<tr class="separator:af5497c22d61d56489cbca457a5e7f047 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2ab388cbeccec46d1dc63e66ea5ec7"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aaa2ab388cbeccec46d1dc63e66ea5ec7">hash</a></td></tr>
<tr class="memdesc:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives that you use. <br/></td></tr>
<tr class="separator:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0847071460189800f9002e2d03ef99 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b0847071460189800f9002e2d03ef99"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b0847071460189800f9002e2d03ef99">item_counter</a></td></tr>
<tr class="memdesc:a7b0847071460189800f9002e2d03ef99 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br/></td></tr>
<tr class="separator:a7b0847071460189800f9002e2d03ef99 inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb1e96121f36af3252e2aa1ea09ff1b"></a>
typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a></td></tr>
<tr class="memdesc:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br/></td></tr>
<tr class="separator:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944c54c5061ce4d8d2b04dbe1dea152f inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a944c54c5061ce4d8d2b04dbe1dea152f"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a></td></tr>
<tr class="memdesc:a944c54c5061ce4d8d2b04dbe1dea152f inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br/></td></tr>
<tr class="separator:a944c54c5061ce4d8d2b04dbe1dea152f inherit pub_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:aa5670755719b66f046d52f43292a0611 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aa5670755719b66f046d52f43292a0611">SplitListSet</a> ()</td></tr>
<tr class="memdesc:aa5670755719b66f046d52f43292a0611 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list of default capacity.  <a href="#aa5670755719b66f046d52f43292a0611">More...</a><br/></td></tr>
<tr class="separator:aa5670755719b66f046d52f43292a0611 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16928087454c9e0ac58e2eb94a2346b2 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a16928087454c9e0ac58e2eb94a2346b2">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a16928087454c9e0ac58e2eb94a2346b2 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list.  <a href="#a16928087454c9e0ac58e2eb94a2346b2">More...</a><br/></td></tr>
<tr class="separator:a16928087454c9e0ac58e2eb94a2346b2 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dedb00d0e55b82a0f7975993c9b2975 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5dedb00d0e55b82a0f7975993c9b2975">begin</a> ()</td></tr>
<tr class="memdesc:a5dedb00d0e55b82a0f7975993c9b2975 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set.  <a href="#a5dedb00d0e55b82a0f7975993c9b2975">More...</a><br/></td></tr>
<tr class="separator:a5dedb00d0e55b82a0f7975993c9b2975 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53acbc7da38bd1884be534bce6bebe4e inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53acbc7da38bd1884be534bce6bebe4e"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a53acbc7da38bd1884be534bce6bebe4e">begin</a> () const</td></tr>
<tr class="memdesc:a53acbc7da38bd1884be534bce6bebe4e inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a53acbc7da38bd1884be534bce6bebe4e inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae399126f499a0d084959f66a6dc5115d inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae399126f499a0d084959f66a6dc5115d">end</a> ()</td></tr>
<tr class="memdesc:ae399126f499a0d084959f66a6dc5115d inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a set.  <a href="#ae399126f499a0d084959f66a6dc5115d">More...</a><br/></td></tr>
<tr class="separator:ae399126f499a0d084959f66a6dc5115d inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3aa2d459a68456441ec09726957a0f inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f3aa2d459a68456441ec09726957a0f"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3f3aa2d459a68456441ec09726957a0f">end</a> () const</td></tr>
<tr class="memdesc:a3f3aa2d459a68456441ec09726957a0f inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:a3f3aa2d459a68456441ec09726957a0f inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffc4541e96c58705ad55b1b416488eb inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5ffc4541e96c58705ad55b1b416488eb">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a5ffc4541e96c58705ad55b1b416488eb inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5ffc4541e96c58705ad55b1b416488eb">More...</a><br/></td></tr>
<tr class="separator:a5ffc4541e96c58705ad55b1b416488eb inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e36d03c7a55355574dd6597e3e5bc8 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a29e36d03c7a55355574dd6597e3e5bc8">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a29e36d03c7a55355574dd6597e3e5bc8 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a29e36d03c7a55355574dd6597e3e5bc8">More...</a><br/></td></tr>
<tr class="separator:a29e36d03c7a55355574dd6597e3e5bc8 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a347a71108230967dfb626ebfd6339d inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3a347a71108230967dfb626ebfd6339d">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3a347a71108230967dfb626ebfd6339d inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a3a347a71108230967dfb626ebfd6339d">More...</a><br/></td></tr>
<tr class="separator:a3a347a71108230967dfb626ebfd6339d inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b2cd4b369e4ce3ecebd68a56753c53 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a61b2cd4b369e4ce3ecebd68a56753c53">ensure</a> (Q const &amp;val, Func func)</td></tr>
<tr class="memdesc:a61b2cd4b369e4ce3ecebd68a56753c53 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>item</code> exists in the set.  <a href="#a61b2cd4b369e4ce3ecebd68a56753c53">More...</a><br/></td></tr>
<tr class="separator:a61b2cd4b369e4ce3ecebd68a56753c53 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79de44e57ed7a992995eb9d81cfb41e inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab79de44e57ed7a992995eb9d81cfb41e">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ab79de44e57ed7a992995eb9d81cfb41e inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#ab79de44e57ed7a992995eb9d81cfb41e">More...</a><br/></td></tr>
<tr class="separator:ab79de44e57ed7a992995eb9d81cfb41e inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5b1e1f60b52aeab4963ff44d17f2f347">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#a5b1e1f60b52aeab4963ff44d17f2f347">More...</a><br/></td></tr>
<tr class="separator:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6216eb4f162b274299a6e31c5713c inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#afcd6216eb4f162b274299a6e31c5713c">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:afcd6216eb4f162b274299a6e31c5713c inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#afcd6216eb4f162b274299a6e31c5713c">More...</a><br/></td></tr>
<tr class="separator:afcd6216eb4f162b274299a6e31c5713c inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564ef5c7e381397898aa53b83c58d58 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ac564ef5c7e381397898aa53b83c58d58">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ac564ef5c7e381397898aa53b83c58d58 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ac564ef5c7e381397898aa53b83c58d58">More...</a><br/></td></tr>
<tr class="separator:ac564ef5c7e381397898aa53b83c58d58 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e441ead0b14b30fcff9614d6170229 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae1e441ead0b14b30fcff9614d6170229">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:ae1e441ead0b14b30fcff9614d6170229 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#ae1e441ead0b14b30fcff9614d6170229">More...</a><br/></td></tr>
<tr class="separator:ae1e441ead0b14b30fcff9614d6170229 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0bdc3ae9c3be2ca3a4d0b1b35269a inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5fb0bdc3ae9c3be2ca3a4d0b1b35269a">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a5fb0bdc3ae9c3be2ca3a4d0b1b35269a inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a5fb0bdc3ae9c3be2ca3a4d0b1b35269a">More...</a><br/></td></tr>
<tr class="separator:a5fb0bdc3ae9c3be2ca3a4d0b1b35269a inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0024dde9c8150cc8e19c5e0ff9bda04b inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a0024dde9c8150cc8e19c5e0ff9bda04b">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a0024dde9c8150cc8e19c5e0ff9bda04b inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a0024dde9c8150cc8e19c5e0ff9bda04b">More...</a><br/></td></tr>
<tr class="separator:a0024dde9c8150cc8e19c5e0ff9bda04b inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759a982857dc449b42af60e3a5d7ddc inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5759a982857dc449b42af60e3a5d7ddc">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a5759a982857dc449b42af60e3a5d7ddc inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a5759a982857dc449b42af60e3a5d7ddc">More...</a><br/></td></tr>
<tr class="separator:a5759a982857dc449b42af60e3a5d7ddc inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f8146539d66c1a2acd0c4b2606618 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae86f8146539d66c1a2acd0c4b2606618">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ae86f8146539d66c1a2acd0c4b2606618 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#ae86f8146539d66c1a2acd0c4b2606618">More...</a><br/></td></tr>
<tr class="separator:ae86f8146539d66c1a2acd0c4b2606618 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc512906766a667cf2bca4e984123927 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#abc512906766a667cf2bca4e984123927">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:abc512906766a667cf2bca4e984123927 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#abc512906766a667cf2bca4e984123927">More...</a><br/></td></tr>
<tr class="separator:abc512906766a667cf2bca4e984123927 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472496ebd650294f6a3d7695bb1b4a6 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a1472496ebd650294f6a3d7695bb1b4a6">clear</a> ()</td></tr>
<tr class="memdesc:a1472496ebd650294f6a3d7695bb1b4a6 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a1472496ebd650294f6a3d7695bb1b4a6">More...</a><br/></td></tr>
<tr class="separator:a1472496ebd650294f6a3d7695bb1b4a6 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ce6b20ce55b786a6338dd13fcc5b16 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab6ce6b20ce55b786a6338dd13fcc5b16">empty</a> () const</td></tr>
<tr class="memdesc:ab6ce6b20ce55b786a6338dd13fcc5b16 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#ab6ce6b20ce55b786a6338dd13fcc5b16">More...</a><br/></td></tr>
<tr class="separator:ab6ce6b20ce55b786a6338dd13fcc5b16 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb246e095d3236f2eafd4e5a330488 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97eb246e095d3236f2eafd4e5a330488"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a97eb246e095d3236f2eafd4e5a330488">size</a> () const</td></tr>
<tr class="memdesc:a97eb246e095d3236f2eafd4e5a330488 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:a97eb246e095d3236f2eafd4e5a330488 inherit pub_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename Key, typename Value, class Traits = split_list::type_traits&gt;<br/>
class cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;</h3>

<p>Split-ordered list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu"></a> Hash table implementation based on split-ordered list algorithm discovered by Ori Shalev and Nir Shavit, see</p>
<ul>
<li>[2003] Ori Shalev, Nir Shavit "Split-Ordered Lists - Lock-free Resizable Hash Tables"</li>
<li>[2008] Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>See <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html" title="Split-ordered list.">intrusive::SplitListSet</a> for a brief description of the split-list algorithm.</p>
<p>Template parameters:</p>
<ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type of an item stored in the map. It should be copy-constructible</li>
<li><code>Value</code> - value type stored in the map</li>
<li><code>Traits</code> - type traits, default is <a class="el" href="structcds_1_1container_1_1split__list_1_1type__traits.html" title="Type traits for SplitListSet class.">split_list::type_traits</a>. Instead of declaring <a class="el" href="structcds_1_1container_1_1split__list_1_1type__traits.html" title="Type traits for SplitListSet class.">split_list::type_traits</a> -based struct you may apply option-based notation with <a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct.">split_list::make_traits</a> metafunction.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> and <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>). The iteration is unordered.</p>
<p>You may iterate over split-list map items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any map's item cannot be reclaimed.</p>
<p>The requirement of RCU lock during iterating means that deletion of the elements (i.e. <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aebb1f2b166d2b12f9f2a84344e264003">erase</a>) is not possible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads</dd>
<dd>
Due to concurrent nature of split-list map it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the map, and your iteration can be terminated before end of the map. Therefore, such iteration is more suitable for debugging purposes</dd></dl>
<p>The iterator class supports the following minimalistic interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a>( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; s) ;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a> * operator -&gt;() <span class="keyword">const</span> ;</div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a>&amp; operator *() <span class="keyword">const</span> ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a>&amp; operator ++() ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a>&amp; src) ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>, <code>cend</code> member functions points to <code>NULL</code> and should not be dereferenced.</p>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
<p>You should decide what garbage collector you want, and what ordered list you want to use. Split-ordered list is original data structure based on an ordered list. Suppose, you want construct split-list map based on cds::urcu::general_buffered&lt;&gt; GC and <a class="el" href="classcds_1_1container_1_1_michael_list.html" title="Michael&#39;s ordered list.">MichaelList</a> as ordered list implementation. Your map should map <code>int</code> key to <code>std::string</code> value. So, you beginning your program with following include: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_rcu.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/split_list_map_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>cc = cds::container ;</div>
</div><!-- fragment --><p> The inclusion order is important:</p>
<ul>
<li>first, include one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU implementation</a> (<code>cds/urcu/general_buffered.h</code> in our case)</li>
<li>second, include file for ordered-list implementation (for this example, <code>cds/container/michael_list_rcu.h</code>),</li>
<li>then, the header for RCU-based split-list set <code>cds/container/split_list_map_rcu.h</code>.</li>
</ul>
<p>Now, you should declare traits for split-list map. The main parts of traits are a hash functor for the map key and a comparing functor for ordered list. We use <code>std::hash&lt;int&gt;</code> as hash functor and <code>std::less&lt;int&gt;</code> predicate as comparing functor.</p>
<p>The second attention: instead of using MichaelList in SplitListMap traits we use a tag <code>cds::contaner::michael_list_tag</code> for the Michael's list. The split-list requires significant support from underlying ordered list class and it is not good idea to dive you into deep implementation details of split-list and ordered list interrelations. The tag paradigm simplifies split-list interface.</p>
<div class="fragment"><div class="line"><span class="comment">// SplitListMap traits</span></div>
<div class="line"><span class="keyword">struct </span>foo_set_traits: <span class="keyword">public</span> cc::split_list::type_traits</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> cc::michael_list_tag   <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad4e33ceb9acfeec3ae22f3e54075bf40" title="Underlying ordered list class.">ordered_list</a>    ;   <span class="comment">// what type of ordered list we want to use</span></div>
<div class="line">    <span class="keyword">typedef</span> std::hash&lt;int&gt;         <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad3f287833bda6211df83817d566d526d" title="Hash functor for key_type.">hash</a>            ;   <span class="comment">// hash functor for the key stored in split-list map</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Type traits for our MichaelList class</span></div>
<div class="line">    <span class="keyword">struct </span>ordered_list_traits: <span class="keyword">public</span> cc::michael_list::type_traits</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typedef</span> std::less&lt;int&gt; less   ;   <span class="comment">// use our std::less predicate as comparator to order list nodes</span></div>
<div class="line">    } ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now you are ready to declare our map class based on <code>SplitListMap</code>: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cc::SplitListMap&lt; cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;, int, std::string, foo_set_traits &gt; int_string_map ;</div>
</div><!-- fragment --><p>You may use the modern option-based declaration instead of classic type-traits-based one: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cc:<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a0392614ddcd0ada7bb78136dc97bbc85" title="Initializes split-ordered map of default capacity.">SplitListMap</a>&lt;</div>
<div class="line">    <a class="code" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt;</a> &gt;  <span class="comment">// RCU type</span></div>
<div class="line">    ,<span class="keywordtype">int</span>                    <span class="comment">// key type</span></div>
<div class="line">    ,std::string            <span class="comment">// value type</span></div>
<div class="line">    ,cc::split_list::make_traits&lt;      <span class="comment">// metafunction to build split-list traits</span></div>
<div class="line">        cc::split_list::ordered_list&lt;cc::michael_list_tag&gt;     <span class="comment">// tag for underlying ordered list implementation</span></div>
<div class="line">        ,cc::opt::hash&lt; std::hash&lt;int&gt; &gt;        <span class="comment">// hash functor</span></div>
<div class="line">        ,cc::split_list::ordered_list_traits&lt;    <span class="comment">// ordered list traits desired</span></div>
<div class="line">            cc::michael_list::make_traits&lt;    <span class="comment">// metafunction to build lazy list traits</span></div>
<div class="line">                cc::opt::less&lt; std::less&lt;int&gt; &gt;         <span class="comment">// less-based compare functor</span></div>
<div class="line">            &gt;::type</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt;  int_string_map ;</div>
</div><!-- fragment --><p> In case of option-based declaration using <a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct.">split_list::make_traits</a> metafunction the struct <code>foo_set_traits</code> is not required.</p>
<p>Now, the map of type <code>int_string_map</code> is ready to use in your program.</p>
<p>Note that in this example we show only mandatory type_traits parts, optional ones is the default and they are inherited from <a class="el" href="structcds_1_1container_1_1split__list_1_1type__traits.html" title="Type traits for SplitListSet class.">cds::container::split_list::type_traits</a>. The <b>cds</b> library contains many other options for deep tuning of behavior of the split-list and ordered-list containers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0392614ddcd0ada7bb78136dc97bbc85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map.html">SplitListMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered map of default capacity. </p>
<p>The default capacity is defined in bucket table constructor. See <a class="el" href="classcds_1_1intrusive_1_1split__list_1_1expandable__bucket__table.html" title="Expandable bucket table.">intrusive::split_list::expandable_bucket_table</a>, <a class="el" href="classcds_1_1intrusive_1_1split__list_1_1static__bucket__table.html" title="Static bucket table.">intrusive::split_list::static_bucket_table</a> which selects by <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1dynamic__bucket__table.html" title="[value-option] Split-list dynamic bucket table option">intrusive::split_list::dynamic_bucket_table</a> option. </p>

</div>
</div>
<a class="anchor" id="a4bcf30da24623b50f97a1f5e49e2bc55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map.html">SplitListMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nItemCount</td><td>estimate average item count </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor - average item count per bucket. Small integer up to 10, default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2e9a7ffed701fe108e98e27790782042"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a map. </p>
<p>For empty map</p>
<div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042" title="Returns a forward iterator addressing the first element in a map.">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52" title="Returns an iterator that addresses the location succeeding the last element in a map.">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a22bba93ee1391b60e4155702a3f32fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the map (non-atomic) </p>
<p>The function unlink all items from the map. The function is not atomic and not lock-free and should be used for debugging only.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a9c7d84aee09c4327f325c43a43548600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p><code>key_type</code> should be constructible from type <code>K</code> </p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics </dd></dl>

</div>
</div>
<a class="anchor" id="a524158157038188845708bc6058b630f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. Thus, the correct item counting is an important part of the map implementation. </p>

</div>
</div>
<a class="anchor" id="a9411b38419a5dc5ce92ba48f48339e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a map. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the map. For empty map</p>
<div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042" title="Returns a forward iterator addressing the first element in a map.">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52" title="Returns an iterator that addresses the location succeeding the last element in a map.">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a031c0a51dd45f45e0bf691ca339f9358"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>key</code> exists in the map. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map (note that in this case the <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> may be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the list. </p>

</div>
</div>
<a class="anchor" id="aebb1f2b166d2b12f9f2a84344e264003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_erase_val"></a> RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a4e0d10489ab3ad0da3fd7ed9aa32e994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a6e6674c5f0b6b4f0f523fcd4cba878c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a93282b6aba0332c6fce60c3fedf23115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="ab1b497490353d85557018c5b908f82f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change <code>item.second</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the map's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6f06e21259a38fb015db22d81348a510"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_find_val"></a> The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="ad593abbddb349e7e7d5642269f70d0cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a7492e25910ec4403e15669d785c8b7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_find_val">find(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a9732e42943b07d8e216d25c42def7f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> should be constructible from value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> should be default-constructible.</li>
</ul>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a37e1da831a875c8ef38964f7a63d68fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae06630bb49b75d1a4c6768b5f10296f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5" title="key-value pair type">value_type</a>&amp; item )  ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p>
<ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>It should be keep in mind that concurrent modifications of <code><code>item.second</code></code> may be possible. User-defined functor <code>func</code> should guarantee that during changing item's value no any other changes could be made on this <code>item</code> by concurrent threads.</p>
<p>The user-defined functor can be passed by reference using <code>boost::ref</code> and it is called only if inserting is successful.</p>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/split_list_map_rcu.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:57 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
