<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">MichaelHashMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Michael's hash map.  
 <a href="classcds_1_1container_1_1_michael_hash_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/michael_map.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4b215ae40c6d0b676f98a7b3a03dc84d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b215ae40c6d0b676f98a7b3a03dc84d"></a>
typedef OrderedList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a></td></tr>
<tr class="memdesc:a4b215ae40c6d0b676f98a7b3a03dc84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list used as a bucket implementation <br/></td></tr>
<tr class="separator:a4b215ae40c6d0b676f98a7b3a03dc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08213f4bb497d620f4032679c655096"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab08213f4bb497d620f4032679c655096"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab08213f4bb497d620f4032679c655096">options</a></td></tr>
<tr class="memdesc:ab08213f4bb497d620f4032679c655096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameters. <br/></td></tr>
<tr class="separator:ab08213f4bb497d620f4032679c655096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17107223d19776ad3d0cdf29591cc545"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17107223d19776ad3d0cdf29591cc545"></a>
typedef bucket_type::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a></td></tr>
<tr class="memdesc:a17107223d19776ad3d0cdf29591cc545"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br/></td></tr>
<tr class="separator:a17107223d19776ad3d0cdf29591cc545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda51f0e406218af58dba7fe30edccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bda51f0e406218af58dba7fe30edccb"></a>
typedef bucket_type::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a></td></tr>
<tr class="memdesc:a6bda51f0e406218af58dba7fe30edccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type <br/></td></tr>
<tr class="separator:a6bda51f0e406218af58dba7fe30edccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4518129d579bbd5bc4612264d6cff2a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4518129d579bbd5bc4612264d6cff2a6"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a></td></tr>
<tr class="memdesc:a4518129d579bbd5bc4612264d6cff2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">key/value pair stored in the list <br/></td></tr>
<tr class="separator:a4518129d579bbd5bc4612264d6cff2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa372ab7a6e082dd3bb697a126402dc3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa372ab7a6e082dd3bb697a126402dc3b"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#aa372ab7a6e082dd3bb697a126402dc3b">gc</a></td></tr>
<tr class="memdesc:aa372ab7a6e082dd3bb697a126402dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:aa372ab7a6e082dd3bb697a126402dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c6632d046a7b05abd0a8a652675d3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c6632d046a7b05abd0a8a652675d3f"></a>
typedef bucket_type::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#af9c6632d046a7b05abd0a8a652675d3f">key_comparator</a></td></tr>
<tr class="memdesc:af9c6632d046a7b05abd0a8a652675d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparision functor <br/></td></tr>
<tr class="separator:af9c6632d046a7b05abd0a8a652675d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85698d86f2bfb30d58f08315362ded5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85698d86f2bfb30d58f08315362ded5c"></a>
typedef <br class="typebreak"/>
cds::opt::v::hash_selector<br class="typebreak"/>
&lt; typename options::hash &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a85698d86f2bfb30d58f08315362ded5c">hash</a></td></tr>
<tr class="memdesc:a85698d86f2bfb30d58f08315362ded5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> and all its derivatives that you use. <br/></td></tr>
<tr class="separator:a85698d86f2bfb30d58f08315362ded5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165bbb53fa403fdbfba6f9effa314bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a165bbb53fa403fdbfba6f9effa314bb2"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a165bbb53fa403fdbfba6f9effa314bb2">item_counter</a></td></tr>
<tr class="memdesc:a165bbb53fa403fdbfba6f9effa314bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br/></td></tr>
<tr class="separator:a165bbb53fa403fdbfba6f9effa314bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae204e8944457948387cc999a4cd546e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae204e8944457948387cc999a4cd546e9"></a>
typedef <br class="typebreak"/>
<a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a>, typename <br class="typebreak"/>
options::allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae204e8944457948387cc999a4cd546e9">bucket_table_allocator</a></td></tr>
<tr class="memdesc:ae204e8944457948387cc999a4cd546e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table allocator. <br/></td></tr>
<tr class="separator:ae204e8944457948387cc999a4cd546e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcebb900b3a0a09eadb916a458e9b6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcebb900b3a0a09eadb916a458e9b6a3"></a>
typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a></td></tr>
<tr class="memdesc:afcebb900b3a0a09eadb916a458e9b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br/></td></tr>
<tr class="separator:afcebb900b3a0a09eadb916a458e9b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b04694f85fd34390928dd1744bdbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf5b04694f85fd34390928dd1744bdbb"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a></td></tr>
<tr class="memdesc:adf5b04694f85fd34390928dd1744bdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br/></td></tr>
<tr class="separator:adf5b04694f85fd34390928dd1744bdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae837465b5c985e4856f4c368f638a097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a> ()</td></tr>
<tr class="memdesc:ae837465b5c985e4856f4c368f638a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map.  <a href="#ae837465b5c985e4856f4c368f638a097">More...</a><br/></td></tr>
<tr class="separator:ae837465b5c985e4856f4c368f638a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2ff57ccf188ead667fdf511f89adf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a> ()</td></tr>
<tr class="memdesc:a6d2ff57ccf188ead667fdf511f89adf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a map.  <a href="#a6d2ff57ccf188ead667fdf511f89adf5">More...</a><br/></td></tr>
<tr class="separator:a6d2ff57ccf188ead667fdf511f89adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4756d55e75b439fe75adb6aebc5b19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5b4756d55e75b439fe75adb6aebc5b19">MichaelHashMap</a> (size_t nMaxItemCount, size_t nLoadFactor)</td></tr>
<tr class="memdesc:a5b4756d55e75b439fe75adb6aebc5b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the map.  <a href="#a5b4756d55e75b439fe75adb6aebc5b19">More...</a><br/></td></tr>
<tr class="separator:a5b4756d55e75b439fe75adb6aebc5b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e452259d93feef1e414ad2a997fc504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e452259d93feef1e414ad2a997fc504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6e452259d93feef1e414ad2a997fc504">~MichaelHashMap</a> ()</td></tr>
<tr class="memdesc:a6e452259d93feef1e414ad2a997fc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears hash map and destroys it. <br/></td></tr>
<tr class="separator:a6e452259d93feef1e414ad2a997fc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6811eed99b256e4b43d236c70f76f89d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a6811eed99b256e4b43d236c70f76f89d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6811eed99b256e4b43d236c70f76f89d">insert</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a6811eed99b256e4b43d236c70f76f89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a6811eed99b256e4b43d236c70f76f89d">More...</a><br/></td></tr>
<tr class="separator:a6811eed99b256e4b43d236c70f76f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbf87015ecd7d552832e0e57d498149"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:addbf87015ecd7d552832e0e57d498149"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#addbf87015ecd7d552832e0e57d498149">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:addbf87015ecd7d552832e0e57d498149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#addbf87015ecd7d552832e0e57d498149">More...</a><br/></td></tr>
<tr class="separator:addbf87015ecd7d552832e0e57d498149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8088f941264023c0b8e28ed63aaa49b0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a8088f941264023c0b8e28ed63aaa49b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a8088f941264023c0b8e28ed63aaa49b0">insert_key</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:a8088f941264023c0b8e28ed63aaa49b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a8088f941264023c0b8e28ed63aaa49b0">More...</a><br/></td></tr>
<tr class="separator:a8088f941264023c0b8e28ed63aaa49b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f84ff4b3e623ade646fb5ea539f136"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a03f84ff4b3e623ade646fb5ea539f136"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a03f84ff4b3e623ade646fb5ea539f136">ensure</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a03f84ff4b3e623ade646fb5ea539f136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>key</code> exists in the map.  <a href="#a03f84ff4b3e623ade646fb5ea539f136">More...</a><br/></td></tr>
<tr class="separator:a03f84ff4b3e623ade646fb5ea539f136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1536210a794b018de5943db1ff6e80"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a3f1536210a794b018de5943db1ff6e80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a3f1536210a794b018de5943db1ff6e80">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3f1536210a794b018de5943db1ff6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a3f1536210a794b018de5943db1ff6e80">More...</a><br/></td></tr>
<tr class="separator:a3f1536210a794b018de5943db1ff6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e87d786b614fe694467bbd91daecbc"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ab3e87d786b614fe694467bbd91daecbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab3e87d786b614fe694467bbd91daecbc">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ab3e87d786b614fe694467bbd91daecbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#ab3e87d786b614fe694467bbd91daecbc">More...</a><br/></td></tr>
<tr class="separator:ab3e87d786b614fe694467bbd91daecbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5e9dbb7e4991a31b78237f2ef3671307">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5e9dbb7e4991a31b78237f2ef3671307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a5e9dbb7e4991a31b78237f2ef3671307">More...</a><br/></td></tr>
<tr class="separator:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab078ecdb8dde43dd992e9f63fc96c7a3">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#ab078ecdb8dde43dd992e9f63fc96c7a3">More...</a><br/></td></tr>
<tr class="separator:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382ac299a8ccda2272ec27296361da8c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a382ac299a8ccda2272ec27296361da8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a382ac299a8ccda2272ec27296361da8c">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a382ac299a8ccda2272ec27296361da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a382ac299a8ccda2272ec27296361da8c">More...</a><br/></td></tr>
<tr class="separator:a382ac299a8ccda2272ec27296361da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a463d8d7851dedae6fcc0d9b0d82c2e6d">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a463d8d7851dedae6fcc0d9b0d82c2e6d">More...</a><br/></td></tr>
<tr class="separator:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcdb0d94caf721d23c8d867f9e26336"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:acfcdb0d94caf721d23c8d867f9e26336"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#acfcdb0d94caf721d23c8d867f9e26336">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:acfcdb0d94caf721d23c8d867f9e26336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#acfcdb0d94caf721d23c8d867f9e26336">More...</a><br/></td></tr>
<tr class="separator:acfcdb0d94caf721d23c8d867f9e26336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b3b08af8be42e85831ddcae00e2939"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ae8b3b08af8be42e85831ddcae00e2939"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae8b3b08af8be42e85831ddcae00e2939">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ae8b3b08af8be42e85831ddcae00e2939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#ae8b3b08af8be42e85831ddcae00e2939">More...</a><br/></td></tr>
<tr class="separator:ae8b3b08af8be42e85831ddcae00e2939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf48eb867cbe38af2e2d3da88d07382"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a5bf48eb867cbe38af2e2d3da88d07382"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5bf48eb867cbe38af2e2d3da88d07382">find_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5bf48eb867cbe38af2e2d3da88d07382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a5bf48eb867cbe38af2e2d3da88d07382">More...</a><br/></td></tr>
<tr class="separator:a5bf48eb867cbe38af2e2d3da88d07382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929894210bf7b045d646f82ab175aa6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a929894210bf7b045d646f82ab175aa6b">clear</a> ()</td></tr>
<tr class="memdesc:a929894210bf7b045d646f82ab175aa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (non-atomic)  <a href="#a929894210bf7b045d646f82ab175aa6b">More...</a><br/></td></tr>
<tr class="separator:a929894210bf7b045d646f82ab175aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8010a7896995c83154ecfe1ae3ddd521"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a8010a7896995c83154ecfe1ae3ddd521">empty</a> () const </td></tr>
<tr class="memdesc:a8010a7896995c83154ecfe1ae3ddd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a8010a7896995c83154ecfe1ae3ddd521">More...</a><br/></td></tr>
<tr class="separator:a8010a7896995c83154ecfe1ae3ddd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5fcc6a6e136013a8e2c488a5dca9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c5fcc6a6e136013a8e2c488a5dca9a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a95c5fcc6a6e136013a8e2c488a5dca9a">size</a> () const </td></tr>
<tr class="memdesc:a95c5fcc6a6e136013a8e2c488a5dca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br/></td></tr>
<tr class="separator:a95c5fcc6a6e136013a8e2c488a5dca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373126e1df3c7c05000ccc9959302174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a373126e1df3c7c05000ccc9959302174">bucket_count</a> () const </td></tr>
<tr class="memdesc:a373126e1df3c7c05000ccc9959302174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a373126e1df3c7c05000ccc9959302174">More...</a><br/></td></tr>
<tr class="separator:a373126e1df3c7c05000ccc9959302174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad22645b6267987a11ce7b5fe8324a98e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22645b6267987a11ce7b5fe8324a98e"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ad22645b6267987a11ce7b5fe8324a98e">begin</a> () const </td></tr>
<tr class="memdesc:ad22645b6267987a11ce7b5fe8324a98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br/></td></tr>
<tr class="separator:ad22645b6267987a11ce7b5fe8324a98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad0fc9567bc3a0a878a5f1771642225"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad0fc9567bc3a0a878a5f1771642225"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> ()</td></tr>
<tr class="separator:a3ad0fc9567bc3a0a878a5f1771642225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a257f2a8fde1a33078c2385a3e900460f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257f2a8fde1a33078c2385a3e900460f"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a257f2a8fde1a33078c2385a3e900460f">end</a> () const </td></tr>
<tr class="memdesc:a257f2a8fde1a33078c2385a3e900460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br/></td></tr>
<tr class="separator:a257f2a8fde1a33078c2385a3e900460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09bdd962595f40169a276d8289c5c55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae09bdd962595f40169a276d8289c5c55"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> ()</td></tr>
<tr class="separator:ae09bdd962595f40169a276d8289c5c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1e4664a54caaaba77751cf310374da73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e4664a54caaaba77751cf310374da73"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a1e4664a54caaaba77751cf310374da73">hash_value</a> (<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> const &amp;key) const </td></tr>
<tr class="memdesc:a1e4664a54caaaba77751cf310374da73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates hash value of <code>key</code>. <br/></td></tr>
<tr class="separator:a1e4664a54caaaba77751cf310374da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8700b5b3bac3e950d992b7c26f9316e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8700b5b3bac3e950d992b7c26f9316e4"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a8700b5b3bac3e950d992b7c26f9316e4">bucket</a> (<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> const &amp;key)</td></tr>
<tr class="memdesc:a8700b5b3bac3e950d992b7c26f9316e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bucket (ordered list) for <code>key</code>. <br/></td></tr>
<tr class="separator:a8700b5b3bac3e950d992b7c26f9316e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af0ccd023a75e47e4b13ad541dac8210b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0ccd023a75e47e4b13ad541dac8210b"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a165bbb53fa403fdbfba6f9effa314bb2">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#af0ccd023a75e47e4b13ad541dac8210b">m_ItemCounter</a></td></tr>
<tr class="memdesc:af0ccd023a75e47e4b13ad541dac8210b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br/></td></tr>
<tr class="separator:af0ccd023a75e47e4b13ad541dac8210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93bb22d6f07a3c620954b39ad4fdca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93bb22d6f07a3c620954b39ad4fdca2"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a85698d86f2bfb30d58f08315362ded5c">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ac93bb22d6f07a3c620954b39ad4fdca2">m_HashFunctor</a></td></tr>
<tr class="memdesc:ac93bb22d6f07a3c620954b39ad4fdca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br/></td></tr>
<tr class="separator:ac93bb22d6f07a3c620954b39ad4fdca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e882033a5b6bd969b43b5a4d617c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0e882033a5b6bd969b43b5a4d617c87"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae0e882033a5b6bd969b43b5a4d617c87">m_Buckets</a></td></tr>
<tr class="memdesc:ae0e882033a5b6bd969b43b5a4d617c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket table <br/></td></tr>
<tr class="separator:ae0e882033a5b6bd969b43b5a4d617c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, class OrderedList, class Traits = michael_map::type_traits&gt;<br/>
class cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt;</h3>

<p>Michael's hash map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp"></a> Source:</p>
<ul>
<li>[2002] Maged Michael "High performance dynamic lock-free hash tables and list-based sets"</li>
</ul>
<p>Michael's hash table algorithm is based on lock-free ordered list and it is very simple. The main structure is an array <code>T</code> of size <code>M</code>. Each element in <code>T</code> is basically a pointer to a hash bucket, implemented as a singly linked list. The array of buckets cannot be dynamically expanded. However, each bucket may contain unbounded number of items.</p>
<p>Template parameters are:</p>
<ul>
<li><code>GC</code> - Garbage collector used. You may use any <a class="el" href="group__cds__garbage__collector.html">Garbage collector</a> from the <code>libcds</code> library. Note the <code>GC</code> must be the same as the GC used for <code>OrderedList</code> </li>
<li><code>OrderedList</code> - ordered key-value list implementation used as bucket for hash map, for example, <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list (key-value pair)">MichaelKVList</a> or <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html" title="Lazy ordered list (key-value pair)">LazyKVList</a>. The ordered list implementation specifies the <code>Key</code> and <code>Value</code> types stored in the hash-map, the reclamation schema <code>GC</code> used by hash-map, the comparison functor for the type <code>Key</code> and other features specific for the ordered list.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="namespacecds_1_1container_1_1michael__map.html#a191452e33b5113786b535540050835f7" title="Type traits for MichaelHashMap class.">michael_map::type_traits</a> for explanation.</li>
</ul>
<p>Instead of defining <code>Traits</code> struct you may use option-based syntax with <code>michael_map::make_traits</code> metafunction (this metafunction is a synonym for <a class="el" href="structcds_1_1container_1_1michael__set_1_1make__traits.html" title="Metafunction converting option list to traits struct.">michael_set::make_traits</a>). For <code>michael_map::make_traits</code> the following option may be used:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">opt::hash</a> - mandatory option, specifies hash functor.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - optional, specifies item counting policy. See <a class="el" href="namespacecds_1_1container_1_1michael__map.html#a191452e33b5113786b535540050835f7" title="Type traits for MichaelHashMap class.">michael_map::type_traits</a> for explanation.</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - optional, bucket table allocator. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
</ul>
<p>Many of the class function take a key argument of type <code>K</code> that in general is not <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a>. <code>key_type</code> and an argument of template type <code>K</code> must meet the following requirements:</p>
<ul>
<li><code>key_type</code> should be constructible from value of type <code>K</code>;</li>
<li>the hash functor should be able to calculate correct hash value from argument <code>key</code> of type <code>K:</code> <code> hash( key_type(key) ) == hash( key ) </code></li>
<li>values of type <code>key_type</code> and <code>K</code> should be comparable</li>
</ul>
<p>There are the specializations:</p>
<ul>
<li>for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> - declared in <code>cd/container/michael_map_rcu.h</code>, see <a class="el" href="classcds_1_1container_1_1_michael_hash_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html#cds_nonintrusive_MichaelHashMap_rcu">MichaelHashMap&lt;RCU&gt;</a>.</li>
<li>for <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a> declared in <code>cds/container/michael_map_nogc.h</code>, see <a class="el" href="classcds_1_1container_1_1_michael_hash_map_3_01gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#cds_nonintrusive_MichaelHashMap_nogc">MichaelHashMap&lt;gc::nogc&gt;</a>.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> and <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>). The iteration is unordered. The iterator object is thread-safe: the element pointed by the iterator object is guarded, so, the element cannot be reclaimed while the iterator object is alive. However, passing an iterator object between threads is dangerous.</p>
<dl class="section warning"><dt>Warning</dt><dd>Due to concurrent nature of Michael's set it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the set, and your iteration can be terminated before end of the set. Therefore, such iteration is more suitable for debugging purpose only</dd></dl>
<p>Remember, each iterator object requires an additional hazard pointer, that may be a limited resource for <code>GC</code> like as <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a> and <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a> (for <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector.">gc::PTB</a> the count of guards is unlimited).</p>
<p>The iterator class supports the following minimalistic interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a> {</div>
<div class="line"><span class="comment">// Default ctor</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy ctor</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a>( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; s) ;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a> * operator -&gt;() <span class="keyword">const</span> ;</div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a>&amp; operator *() <span class="keyword">const</span> ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Pre-increment</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a>&amp; operator ++() ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy assignment</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a>&amp; src) ;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line"><span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a>, <code>cend</code> member functions points to <code>NULL</code> and should not be dereferenced.</p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_how_touse"></a><b>How to use</b></p>
<p>Suppose, you want to make <code>int</code> to <code>int</code> map for Hazard Pointer garbage collector. You should choose suitable ordered list class that will be used as a bucket for the map; it may be <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list (key-value pair)">MichaelKVList</a>. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_kvlist_hp.h&gt;</span>    <span class="comment">// MichaelKVList for gc::HP</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/michael_map.h&gt;</span>          <span class="comment">// MIchaelHashMap</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// List traits based on std::less predicate</span></div>
<div class="line"><span class="keyword">struct </span>list_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1michael__list_1_1type__traits.html" title="Michael list default type traits.">cds::container::michael_list::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::less&lt;int&gt;      less ;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Ordered list</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list (key-value pair)">cds::container::MichaelKVList&lt; cds::gc::HP, int, int, list_traits&gt;</a> int2int_list  ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Map traits</span></div>
<div class="line"><span class="keyword">struct </span>map_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1michael__set_1_1type__traits.html" title="Type traits for MichaelHashSet class.">cds::container::michael_map::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a85698d86f2bfb30d58f08315362ded5c" title="Hash functor for key_type and all its derivatives that you use.">hash</a> {</div>
<div class="line">        <span class="keywordtype">size_t</span> operator()( <span class="keywordtype">int</span> i )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> cds::opt::v::hash&lt;int&gt;()( i ) ;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Your map</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html" title="Michael&#39;s hash map.">cds::container::MichaelHashMap&lt; cds::gc::HP, int2int_list, map_traits &gt;</a> int2int_map ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now you can use int2int_map class</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    int2int_map theMap  ;</div>
<div class="line"></div>
<div class="line">    theMap.<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6811eed99b256e4b43d236c70f76f89d" title="Inserts new node with key and default value.">insert</a>( 100 )    ;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>You may use option-based declaration: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_kvlist_hp.h&gt;</span>    <span class="comment">// MichaelKVList for gc::HP</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/michael_map.h&gt;</span>          <span class="comment">// MIchaelHashMap</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Ordered list</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list (key-value pair)">cds::container::MichaelKVList</a>&lt; cds::gc::HP, int, int,</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1container_1_1michael__list_1_1make__traits.html" title="Metafunction converting option list to MichaelList traits.">cds::container::michael_list::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::container::opt::less&lt; std::less&lt;int&gt;</a> &gt;     <span class="comment">// item comparator option</span></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt;  int2int_list   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Map</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html" title="Michael&#39;s hash map.">cds::container::MichaelHashMap</a>&lt; cds::gc::HP, int2int_list,</div>
<div class="line">    cds::container::michael_map::make_traits&lt;</div>
<div class="line">        cc::opt::hash&lt; cds::opt::v::hash&lt;int&gt; &gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; int2int_map ;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5b4756d55e75b439fe75adb6aebc5b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">MichaelHashMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the map. </p>
<p>The Michael's hash map is non-expandable container. You should point the average count of items <code>nMaxItemCount</code> when you create an object. <code>nLoadFactor</code> parameter defines average count of items per bucket and it should be small number between 1 and 10. Remember, since the bucket implementation is an ordered list, searching in the bucket is linear [<code>O(nLoadFactor)</code>]. Note, that many popular STL hash map implementation uses load factor 1.</p>
<p>The ctor defines hash table size as rounding <code>nMacItemCount / nLoadFactor</code> up to nearest power of two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nMaxItemCount</td><td>estimation of max item count in the hash map </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor: estimation of max number of items in the bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae837465b5c985e4856f4c368f638a097"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a map. </p>
<p>For empty map</p>
<div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097" title="Returns a forward iterator addressing the first element in a map.">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5" title="Returns an iterator that addresses the location succeeding the last element in a map.">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a373126e1df3c7c05000ccc9959302174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>Since <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html" title="Michael&#39;s hash map.">MichaelHashMap</a> cannot dynamically extend the hash table size, the value returned is an constant depending on object initialization parameters; see <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5b4756d55e75b439fe75adb6aebc5b19" title="Initializes the map.">MichaelHashMap::MichaelHashMap</a> for explanation. </p>

</div>
</div>
<a class="anchor" id="a929894210bf7b045d646f82ab175aa6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the map (non-atomic) </p>
<p>The function erases all items from the map.</p>
<p>The function is not atomic. It cleans up each bucket and then resets the item counter to zero. If there are a thread that performs insertion while <code>clear</code> is working the result is undefined in general case: <code> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a8010a7896995c83154ecfe1ae3ddd521" title="Checks if the map is empty.">empty()</a> </code> may return <code>true</code> but the map may contain item(s). Therefore, <code>clear</code> may be used only for debugging purposes. </p>

</div>
</div>
<a class="anchor" id="a3f1536210a794b018de5943db1ff6e80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p><code>key_type</code> should be constructible from type <code>K</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>This function is available only for compiler that supports variadic template and move semantics </p>

</div>
</div>
<a class="anchor" id="a8010a7896995c83154ecfe1ae3ddd521"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. Thus, the correct item counting is an important part of the map implementation. </p>

</div>
</div>
<a class="anchor" id="a6d2ff57ccf188ead667fdf511f89adf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a map. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the map. For empty map</p>
<div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097" title="Returns a forward iterator addressing the first element in a map.">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5" title="Returns an iterator that addresses the location succeeding the last element in a map.">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a03f84ff4b3e623ade646fb5ea539f136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>key</code> exists in the map. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map (note that in this case the <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> may be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the list. </p>

</div>
</div>
<a class="anchor" id="ab3e87d786b614fe694467bbd91daecbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="ab078ecdb8dde43dd992e9f63fc96c7a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a5e9dbb7e4991a31b78237f2ef3671307"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a382ac299a8ccda2272ec27296361da8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a463d8d7851dedae6fcc0d9b0d82c2e6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change <code>item.second</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the map's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae8b3b08af8be42e85831ddcae00e2939"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_find_val"></a>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="acfcdb0d94caf721d23c8d867f9e26336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a5bf48eb867cbe38af2e2d3da88d07382"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_find_val">find(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a6811eed99b256e4b43d236c70f76f89d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> should be constructible from value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="addbf87015ecd7d552832e0e57d498149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a8088f941264023c0b8e28ed63aaa49b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6" title="key/value pair stored in the list">value_type</a>&amp; item )  ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p>
<ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>User-defined functor <code>func</code> should guarantee that during changing item's value no any other changes could be made on this map's item by concurrent threads. The user-defined functor can be passed by reference using <code>boost::ref</code> and it is called only if inserting is successful.</p>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/michael_map.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:56 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
