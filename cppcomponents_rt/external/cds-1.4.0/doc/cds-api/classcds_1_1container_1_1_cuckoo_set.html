<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::CuckooSet&lt; T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::CuckooSet&lt; T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cuckoo hash set.  
 <a href="classcds_1_1container_1_1_cuckoo_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/cuckoo_set.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::CuckooSet&lt; T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_cuckoo_set.png" usemap="#cds::container::CuckooSet&lt; T, Traits &gt;_map" alt=""/>
  <map id="cds::container::CuckooSet&lt; T, Traits &gt;_map" name="cds::container::CuckooSet&lt; T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_cuckoo_set.html" title="Cuckoo hash set." alt="cds::intrusive::CuckooSet&lt; T, Traits &gt;" shape="rect" coords="0,0,229,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6960090b98a1b6f318d12a0ded22ecbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6960090b98a1b6f318d12a0ded22ecbf"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a></td></tr>
<tr class="memdesc:a6960090b98a1b6f318d12a0ded22ecbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the container <br/></td></tr>
<tr class="separator:a6960090b98a1b6f318d12a0ded22ecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e3f19eb5f5cf75e3895024df56f55e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e3f19eb5f5cf75e3895024df56f55e"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad8e3f19eb5f5cf75e3895024df56f55e">options</a></td></tr>
<tr class="memdesc:ad8e3f19eb5f5cf75e3895024df56f55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits <br/></td></tr>
<tr class="separator:ad8e3f19eb5f5cf75e3895024df56f55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c55c422ded6d8c897b8f59c12a640"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a113c55c422ded6d8c897b8f59c12a640"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a113c55c422ded6d8c897b8f59c12a640">hash</a></td></tr>
<tr class="memdesc:a113c55c422ded6d8c897b8f59c12a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br/></td></tr>
<tr class="separator:a113c55c422ded6d8c897b8f59c12a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c874038de46f43becf699c9b8a1b5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c874038de46f43becf699c9b8a1b5b"></a>
typedef base_class::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a></td></tr>
<tr class="memdesc:ad0c874038de46f43becf699c9b8a1b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br/></td></tr>
<tr class="separator:ad0c874038de46f43becf699c9b8a1b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b0f96c71eeb8f15fffb0da4b8ee29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9b0f96c71eeb8f15fffb0da4b8ee29"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a9c9b0f96c71eeb8f15fffb0da4b8ee29">mutex_policy</a></td></tr>
<tr class="memdesc:a9c9b0f96c71eeb8f15fffb0da4b8ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <a class="el" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html#ade446cfe4dd89001f2e0b011af348365" title="Concurrent access policy.">cuckoo::type_traits::mutex_policy</a>. <br/></td></tr>
<tr class="separator:a9c9b0f96c71eeb8f15fffb0da4b8ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21b07f4df839096d3c4d111b83aaacd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae21b07f4df839096d3c4d111b83aaacd"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae21b07f4df839096d3c4d111b83aaacd">stat</a></td></tr>
<tr class="memdesc:ae21b07f4df839096d3c4d111b83aaacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:ae21b07f4df839096d3c4d111b83aaacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cca666dbea78deddc8899da05617fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32cca666dbea78deddc8899da05617fb"></a>
typedef base_class::key_equal_to&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a32cca666dbea78deddc8899da05617fb">key_equal_to</a></td></tr>
<tr class="memdesc:a32cca666dbea78deddc8899da05617fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br/></td></tr>
<tr class="separator:a32cca666dbea78deddc8899da05617fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8617f0fae3ae5a6cf938adfd5d861f95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8617f0fae3ae5a6cf938adfd5d861f95"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a8617f0fae3ae5a6cf938adfd5d861f95">key_comparator</a></td></tr>
<tr class="memdesc:a8617f0fae3ae5a6cf938adfd5d861f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option setter. Used only for ordered probe set <br/></td></tr>
<tr class="separator:a8617f0fae3ae5a6cf938adfd5d861f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1c93cb5f3a970c4c5ba9195d262979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e1c93cb5f3a970c4c5ba9195d262979"></a>
typedef base_class::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a2e1c93cb5f3a970c4c5ba9195d262979">allocator</a></td></tr>
<tr class="memdesc:a2e1c93cb5f3a970c4c5ba9195d262979"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type used for internal bucket table allocations <br/></td></tr>
<tr class="separator:a2e1c93cb5f3a970c4c5ba9195d262979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02c065d4467c4ef43b3d4a587d68d9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab02c065d4467c4ef43b3d4a587d68d9a"></a>
typedef std::conditional<br class="typebreak"/>
&lt; std::is_same&lt; typename <br class="typebreak"/>
options::node_allocator, <br class="typebreak"/>
<a class="el" href="structcds_1_1opt_1_1none.html">opt::none</a> &gt;::value, <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a2e1c93cb5f3a970c4c5ba9195d262979">allocator</a>, <br class="typebreak"/>
typename <br class="typebreak"/>
options::node_allocator &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab02c065d4467c4ef43b3d4a587d68d9a">node_allocator</a></td></tr>
<tr class="memdesc:ab02c065d4467c4ef43b3d4a587d68d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator type. <br/></td></tr>
<tr class="separator:ab02c065d4467c4ef43b3d4a587d68d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5138750be83ee823b2ee35a7ff8149a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5138750be83ee823b2ee35a7ff8149a5"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a5138750be83ee823b2ee35a7ff8149a5">item_counter</a></td></tr>
<tr class="memdesc:a5138750be83ee823b2ee35a7ff8149a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br/></td></tr>
<tr class="separator:a5138750be83ee823b2ee35a7ff8149a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1101460328fbacaf3bdc4acd5c0e81e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1101460328fbacaf3bdc4acd5c0e81e7">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a1101460328fbacaf3bdc4acd5c0e81e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a1101460328fbacaf3bdc4acd5c0e81e7">More...</a><br/></td></tr>
<tr class="separator:a1101460328fbacaf3bdc4acd5c0e81e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba8f1383336b8f15853911a4414cb3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a9ba8f1383336b8f15853911a4414cb3f">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:a9ba8f1383336b8f15853911a4414cb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="#a9ba8f1383336b8f15853911a4414cb3f">More...</a><br/></td></tr>
<tr class="separator:a9ba8f1383336b8f15853911a4414cb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b3dacd480c537a3775a04166d19e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a296b3dacd480c537a3775a04166d19e9">CuckooSet</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a296b3dacd480c537a3775a04166d19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="#a296b3dacd480c537a3775a04166d19e9">More...</a><br/></td></tr>
<tr class="separator:a296b3dacd480c537a3775a04166d19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbb45c6bf31fd741fa17f3af1edaca6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aafbb45c6bf31fd741fa17f3af1edaca6">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:aafbb45c6bf31fd741fa17f3af1edaca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="#aafbb45c6bf31fd741fa17f3af1edaca6">More...</a><br/></td></tr>
<tr class="separator:aafbb45c6bf31fd741fa17f3af1edaca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907edd06474f7cc1d153b35c7747c5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aa907edd06474f7cc1d153b35c7747c5c">CuckooSet</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aa907edd06474f7cc1d153b35c7747c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="#aa907edd06474f7cc1d153b35c7747c5c">More...</a><br/></td></tr>
<tr class="separator:aa907edd06474f7cc1d153b35c7747c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa844c23eee0a1f388f732477483b33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a2aa844c23eee0a1f388f732477483b33">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a2aa844c23eee0a1f388f732477483b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="#a2aa844c23eee0a1f388f732477483b33">More...</a><br/></td></tr>
<tr class="separator:a2aa844c23eee0a1f388f732477483b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aeb06f0bf4632b93b9c9a6e1f59332"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21aeb06f0bf4632b93b9c9a6e1f59332"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a21aeb06f0bf4632b93b9c9a6e1f59332">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a21aeb06f0bf4632b93b9c9a6e1f59332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears the set. <br/></td></tr>
<tr class="separator:a21aeb06f0bf4632b93b9c9a6e1f59332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31094d63170ecc65adfba66f838e4736"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a31094d63170ecc65adfba66f838e4736"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a31094d63170ecc65adfba66f838e4736">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a31094d63170ecc65adfba66f838e4736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a31094d63170ecc65adfba66f838e4736">More...</a><br/></td></tr>
<tr class="separator:a31094d63170ecc65adfba66f838e4736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf139c50172cf26e3d94a7c7141c562"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aabf139c50172cf26e3d94a7c7141c562"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aabf139c50172cf26e3d94a7c7141c562">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:aabf139c50172cf26e3d94a7c7141c562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#aabf139c50172cf26e3d94a7c7141c562">More...</a><br/></td></tr>
<tr class="separator:aabf139c50172cf26e3d94a7c7141c562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b66db35b6bd7b25b22b6cab8f84795"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac8b66db35b6bd7b25b22b6cab8f84795"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ac8b66db35b6bd7b25b22b6cab8f84795">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ac8b66db35b6bd7b25b22b6cab8f84795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#ac8b66db35b6bd7b25b22b6cab8f84795">More...</a><br/></td></tr>
<tr class="separator:ac8b66db35b6bd7b25b22b6cab8f84795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d5d2327524b39acb641eaa26f82762"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a10d5d2327524b39acb641eaa26f82762"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a10d5d2327524b39acb641eaa26f82762">ensure</a> (Q const &amp;val, Func func)</td></tr>
<tr class="memdesc:a10d5d2327524b39acb641eaa26f82762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#a10d5d2327524b39acb641eaa26f82762">More...</a><br/></td></tr>
<tr class="separator:a10d5d2327524b39acb641eaa26f82762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a600a2a1f6dee844efa7732c9c37fdbe8">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a600a2a1f6dee844efa7732c9c37fdbe8">More...</a><br/></td></tr>
<tr class="separator:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1cb6ddf92a91d5aa73758d4dd78b03a3">erase_with</a> (Q const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a1cb6ddf92a91d5aa73758d4dd78b03a3">More...</a><br/></td></tr>
<tr class="separator:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087593ff478f76db232f7e6ba664e2a"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae087593ff478f76db232f7e6ba664e2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae087593ff478f76db232f7e6ba664e2a">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:ae087593ff478f76db232f7e6ba664e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#ae087593ff478f76db232f7e6ba664e2a">More...</a><br/></td></tr>
<tr class="separator:ae087593ff478f76db232f7e6ba664e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e746d9a12ec6a109364f57383296b9b"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a0e746d9a12ec6a109364f57383296b9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a0e746d9a12ec6a109364f57383296b9b">erase_with</a> (Q const &amp;key, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a0e746d9a12ec6a109364f57383296b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a0e746d9a12ec6a109364f57383296b9b">More...</a><br/></td></tr>
<tr class="separator:a0e746d9a12ec6a109364f57383296b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a8bc2faf556b0509b97dc9f45ca0ca814">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a8bc2faf556b0509b97dc9f45ca0ca814">More...</a><br/></td></tr>
<tr class="separator:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf720dc7a1496938965d5c3ae9a090"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a90bf720dc7a1496938965d5c3ae9a090"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a90bf720dc7a1496938965d5c3ae9a090">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a90bf720dc7a1496938965d5c3ae9a090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a90bf720dc7a1496938965d5c3ae9a090">More...</a><br/></td></tr>
<tr class="separator:a90bf720dc7a1496938965d5c3ae9a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82fa75613e410f6f66ec78ebd0297ea"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ad82fa75613e410f6f66ec78ebd0297ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad82fa75613e410f6f66ec78ebd0297ea">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ad82fa75613e410f6f66ec78ebd0297ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ad82fa75613e410f6f66ec78ebd0297ea">More...</a><br/></td></tr>
<tr class="separator:ad82fa75613e410f6f66ec78ebd0297ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd375dd6a59a0e6a75452b66c235b34"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a0bd375dd6a59a0e6a75452b66c235b34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a0bd375dd6a59a0e6a75452b66c235b34">find_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a0bd375dd6a59a0e6a75452b66c235b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a0bd375dd6a59a0e6a75452b66c235b34">More...</a><br/></td></tr>
<tr class="separator:a0bd375dd6a59a0e6a75452b66c235b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a4214ffabbf30fa6529ac127258728"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a56a4214ffabbf30fa6529ac127258728"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a56a4214ffabbf30fa6529ac127258728">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a56a4214ffabbf30fa6529ac127258728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a56a4214ffabbf30fa6529ac127258728">More...</a><br/></td></tr>
<tr class="separator:a56a4214ffabbf30fa6529ac127258728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02400da123bb6831b3b1c1d47c3766e"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:ac02400da123bb6831b3b1c1d47c3766e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ac02400da123bb6831b3b1c1d47c3766e">find_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:ac02400da123bb6831b3b1c1d47c3766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#ac02400da123bb6831b3b1c1d47c3766e">More...</a><br/></td></tr>
<tr class="separator:ac02400da123bb6831b3b1c1d47c3766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a224c06b767df1f39e5eb7fb3625a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a17a224c06b767df1f39e5eb7fb3625a5">clear</a> ()</td></tr>
<tr class="memdesc:a17a224c06b767df1f39e5eb7fb3625a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#a17a224c06b767df1f39e5eb7fb3625a5">More...</a><br/></td></tr>
<tr class="separator:a17a224c06b767df1f39e5eb7fb3625a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346358bcaee9005b34cabdfa7e2db675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a346358bcaee9005b34cabdfa7e2db675">empty</a> () const </td></tr>
<tr class="memdesc:a346358bcaee9005b34cabdfa7e2db675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a346358bcaee9005b34cabdfa7e2db675">More...</a><br/></td></tr>
<tr class="separator:a346358bcaee9005b34cabdfa7e2db675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca5765002cf79146d2247d731793aee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acca5765002cf79146d2247d731793aee"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#acca5765002cf79146d2247d731793aee">size</a> () const </td></tr>
<tr class="memdesc:acca5765002cf79146d2247d731793aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:acca5765002cf79146d2247d731793aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbaf1e626c8490383f6799f741d1476"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a5bbaf1e626c8490383f6799f741d1476">bucket_count</a> () const </td></tr>
<tr class="memdesc:a5bbaf1e626c8490383f6799f741d1476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a5bbaf1e626c8490383f6799f741d1476">More...</a><br/></td></tr>
<tr class="separator:a5bbaf1e626c8490383f6799f741d1476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedad968529750ed53eaa2e4196f7f12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acedad968529750ed53eaa2e4196f7f12"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#acedad968529750ed53eaa2e4196f7f12">lock_count</a> () const </td></tr>
<tr class="memdesc:acedad968529750ed53eaa2e4196f7f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br/></td></tr>
<tr class="separator:acedad968529750ed53eaa2e4196f7f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ddf69cdb85804ec4f2272e96d758e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ddf69cdb85804ec4f2272e96d758e7"></a>
<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae21b07f4df839096d3c4d111b83aaacd">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a78ddf69cdb85804ec4f2272e96d758e7">statistics</a> () const </td></tr>
<tr class="memdesc:a78ddf69cdb85804ec4f2272e96d758e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a78ddf69cdb85804ec4f2272e96d758e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e4de7c020170ab02bd3756a5daf811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2e4de7c020170ab02bd3756a5daf811"></a>
mutex_policy::statistics_type <br class="typebreak"/>
const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#af2e4de7c020170ab02bd3756a5daf811">mutex_policy_statistics</a> () const </td></tr>
<tr class="memdesc:af2e4de7c020170ab02bd3756a5daf811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br/></td></tr>
<tr class="separator:af2e4de7c020170ab02bd3756a5daf811"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6777b15dc90e121ace8db149316274c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6777b15dc90e121ace8db149316274c2"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6777b15dc90e121ace8db149316274c2">c_isSorted</a> = base_class::c_isSorted</td></tr>
<tr class="memdesc:a6777b15dc90e121ace8db149316274c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered <br/></td></tr>
<tr class="separator:a6777b15dc90e121ace8db149316274c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab919ab7745976c25c78f3690ef211a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab919ab7745976c25c78f3690ef211a93"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> = base_class::c_nArity</td></tr>
<tr class="memdesc:ab919ab7745976c25c78f3690ef211a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br/></td></tr>
<tr class="separator:ab919ab7745976c25c78f3690ef211a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029af01b7f4957161b5d1852f8deb22e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a029af01b7f4957161b5d1852f8deb22e"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a029af01b7f4957161b5d1852f8deb22e">c_nDefaultProbesetSize</a> = base_class::c_nDefaultProbesetSize</td></tr>
<tr class="memdesc:a029af01b7f4957161b5d1852f8deb22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br/></td></tr>
<tr class="separator:a029af01b7f4957161b5d1852f8deb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99951f1c472fe6bc40ed35693f4df992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99951f1c472fe6bc40ed35693f4df992"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> = base_class::c_nDefaultInitialSize</td></tr>
<tr class="memdesc:a99951f1c472fe6bc40ed35693f4df992"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br/></td></tr>
<tr class="separator:a99951f1c472fe6bc40ed35693f4df992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a56f8c2c7c3ea18231390af8a9164cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a56f8c2c7c3ea18231390af8a9164cd"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6a56f8c2c7c3ea18231390af8a9164cd">c_nRelocateLimit</a> = base_class::c_nRelocateLimit</td></tr>
<tr class="memdesc:a6a56f8c2c7c3ea18231390af8a9164cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br/></td></tr>
<tr class="separator:a6a56f8c2c7c3ea18231390af8a9164cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:a80f3988a87de588e0a2d873592e6da40 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f3988a87de588e0a2d873592e6da40"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a></td></tr>
<tr class="memdesc:a80f3988a87de588e0a2d873592e6da40 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type stored in the set. <br/></td></tr>
<tr class="separator:a80f3988a87de588e0a2d873592e6da40 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec37050e433a8c1d925eda572252fb0d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec37050e433a8c1d925eda572252fb0d"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec37050e433a8c1d925eda572252fb0d">options</a></td></tr>
<tr class="memdesc:aec37050e433a8c1d925eda572252fb0d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br/></td></tr>
<tr class="separator:aec37050e433a8c1d925eda572252fb0d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4cc5921f54a8b8c796699cad5ada8c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa4cc5921f54a8b8c796699cad5ada8c"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aaa4cc5921f54a8b8c796699cad5ada8c">hook</a></td></tr>
<tr class="memdesc:aaa4cc5921f54a8b8c796699cad5ada8c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:aaa4cc5921f54a8b8c796699cad5ada8c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d55d2a0fff222284b2d978b7a0985d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11d55d2a0fff222284b2d978b7a0985d"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a></td></tr>
<tr class="memdesc:a11d55d2a0fff222284b2d978b7a0985d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:a11d55d2a0fff222284b2d978b7a0985d inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af0e1eb823a6d2f1c557686c912c605 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9af0e1eb823a6d2f1c557686c912c605"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aaa4cc5921f54a8b8c796699cad5ada8c">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9af0e1eb823a6d2f1c557686c912c605">node_traits</a></td></tr>
<tr class="memdesc:a9af0e1eb823a6d2f1c557686c912c605 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br/></td></tr>
<tr class="separator:a9af0e1eb823a6d2f1c557686c912c605 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634e9cab4969a594206b1a76e87b8ee1 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a634e9cab4969a594206b1a76e87b8ee1"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a634e9cab4969a594206b1a76e87b8ee1">hash</a></td></tr>
<tr class="memdesc:a634e9cab4969a594206b1a76e87b8ee1 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br/></td></tr>
<tr class="separator:a634e9cab4969a594206b1a76e87b8ee1 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109563a562d2cc52f6819b272923dfa7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109563a562d2cc52f6819b272923dfa7"></a>
typedef hash::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a></td></tr>
<tr class="memdesc:a109563a562d2cc52f6819b272923dfa7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br/></td></tr>
<tr class="separator:a109563a562d2cc52f6819b272923dfa7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b825ee98486afcfc2ae03f0bef294f inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b825ee98486afcfc2ae03f0bef294f"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09b825ee98486afcfc2ae03f0bef294f">stat</a></td></tr>
<tr class="memdesc:a09b825ee98486afcfc2ae03f0bef294f inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a09b825ee98486afcfc2ae03f0bef294f inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc46bccdc9a3f704b49d426e4d7183b0 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc46bccdc9a3f704b49d426e4d7183b0"></a>
typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#abc46bccdc9a3f704b49d426e4d7183b0">original_mutex_policy</a></td></tr>
<tr class="memdesc:abc46bccdc9a3f704b49d426e4d7183b0 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1type__traits.html#a3d0d21ff1e2c7b4b6efb2b868f281f30" title="Concurrent access policy.">cuckoo::type_traits::mutex_policy</a>. <br/></td></tr>
<tr class="separator:abc46bccdc9a3f704b49d426e4d7183b0 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68699b6f6b7957c4f604e4677c9655db inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
original_mutex_policy::template <br class="typebreak"/>
rebind_statistics&lt; typename <br class="typebreak"/>
std::conditional&lt; std::is_same<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09b825ee98486afcfc2ae03f0bef294f">stat</a>, <a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1empty__stat.html">cuckoo::empty_stat</a> &gt;<br class="typebreak"/>
::value,typename <br class="typebreak"/>
original_mutex_policy::empty_stat,typename <br class="typebreak"/>
original_mutex_policy::real_stat &gt;<br class="typebreak"/>
::type &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a68699b6f6b7957c4f604e4677c9655db">mutex_policy</a></td></tr>
<tr class="memdesc:a68699b6f6b7957c4f604e4677c9655db inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual mutex policy.  <a href="#a68699b6f6b7957c4f604e4677c9655db">More...</a><br/></td></tr>
<tr class="separator:a68699b6f6b7957c4f604e4677c9655db inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f0210fc64d5dcb183719c21551778 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7f0210fc64d5dcb183719c21551778"></a>
typedef <br class="typebreak"/>
opt::details::make_equal_to<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec37050e433a8c1d925eda572252fb0d">options</a>,!<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#afe7f0210fc64d5dcb183719c21551778">key_equal_to</a></td></tr>
<tr class="memdesc:afe7f0210fc64d5dcb183719c21551778 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br/></td></tr>
<tr class="separator:afe7f0210fc64d5dcb183719c21551778 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f042d973da8c6cae20c0cc8cb4d0b9 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14f042d973da8c6cae20c0cc8cb4d0b9"></a>
typedef <br class="typebreak"/>
opt::details::make_comparator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec37050e433a8c1d925eda572252fb0d">options</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a14f042d973da8c6cae20c0cc8cb4d0b9">key_comparator</a></td></tr>
<tr class="memdesc:a14f042d973da8c6cae20c0cc8cb4d0b9 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option setter. Used only for ordered probe set <br/></td></tr>
<tr class="separator:a14f042d973da8c6cae20c0cc8cb4d0b9 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9652debeb26265468867f60adddd6d7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9652debeb26265468867f60adddd6d7"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ab9652debeb26265468867f60adddd6d7">allocator</a></td></tr>
<tr class="memdesc:ab9652debeb26265468867f60adddd6d7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type <br/></td></tr>
<tr class="separator:ab9652debeb26265468867f60adddd6d7 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d1717e8d2e1b73b08c422c1b79cc65 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09d1717e8d2e1b73b08c422c1b79cc65"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09d1717e8d2e1b73b08c422c1b79cc65">item_counter</a></td></tr>
<tr class="memdesc:a09d1717e8d2e1b73b08c422c1b79cc65 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br/></td></tr>
<tr class="separator:a09d1717e8d2e1b73b08c422c1b79cc65 inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56745d9580594c19b680d8d0e16e48c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad56745d9580594c19b680d8d0e16e48c"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad56745d9580594c19b680d8d0e16e48c">disposer</a></td></tr>
<tr class="memdesc:ad56745d9580594c19b680d8d0e16e48c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node disposer <br/></td></tr>
<tr class="separator:ad56745d9580594c19b680d8d0e16e48c inherit pub_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3e221ce6294ce2a9bd4ad4e6fe06b367">More...</a><br/></td></tr>
<tr class="separator:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f71b08de102c3ca85b9bc53963b38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac18f71b08de102c3ca85b9bc53963b38">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:ac18f71b08de102c3ca85b9bc53963b38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="#ac18f71b08de102c3ca85b9bc53963b38">More...</a><br/></td></tr>
<tr class="separator:ac18f71b08de102c3ca85b9bc53963b38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cec0e76f68e4d0462420d577c728c76 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a2cec0e76f68e4d0462420d577c728c76">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a2cec0e76f68e4d0462420d577c728c76 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="#a2cec0e76f68e4d0462420d577c728c76">More...</a><br/></td></tr>
<tr class="separator:a2cec0e76f68e4d0462420d577c728c76 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a028ecfbae605b0199e0b0b2d15fd3d73">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="#a028ecfbae605b0199e0b0b2d15fd3d73">More...</a><br/></td></tr>
<tr class="separator:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f68f38da3654e56754e08c94f66d2e inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95f68f38da3654e56754e08c94f66d2e">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a95f68f38da3654e56754e08c94f66d2e inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="#a95f68f38da3654e56754e08c94f66d2e">More...</a><br/></td></tr>
<tr class="separator:a95f68f38da3654e56754e08c94f66d2e inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede715e446da90de4e51b19d64236da3 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aede715e446da90de4e51b19d64236da3">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aede715e446da90de4e51b19d64236da3 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="#aede715e446da90de4e51b19d64236da3">More...</a><br/></td></tr>
<tr class="separator:aede715e446da90de4e51b19d64236da3 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545595f7caba3bdd3520e16115a7fa2b inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545595f7caba3bdd3520e16115a7fa2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a545595f7caba3bdd3520e16115a7fa2b">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a545595f7caba3bdd3520e16115a7fa2b inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a545595f7caba3bdd3520e16115a7fa2b inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75199d012de6ab7c3315dda78b4b3025 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a75199d012de6ab7c3315dda78b4b3025">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a75199d012de6ab7c3315dda78b4b3025 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a75199d012de6ab7c3315dda78b4b3025">More...</a><br/></td></tr>
<tr class="separator:a75199d012de6ab7c3315dda78b4b3025 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a103ae7f5ebd72ac7fe2a1cc751f937bd">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a103ae7f5ebd72ac7fe2a1cc751f937bd">More...</a><br/></td></tr>
<tr class="separator:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a5d5878c5b3002bbe258a8936c9327c31">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#a5d5878c5b3002bbe258a8936c9327c31">More...</a><br/></td></tr>
<tr class="separator:a5d5878c5b3002bbe258a8936c9327c31 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2d0ae24a2a32edc066a96e003e9bb inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44c2d0ae24a2a32edc066a96e003e9bb">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a44c2d0ae24a2a32edc066a96e003e9bb inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="#a44c2d0ae24a2a32edc066a96e003e9bb">More...</a><br/></td></tr>
<tr class="separator:a44c2d0ae24a2a32edc066a96e003e9bb inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9b4514beb5a17fa560faca26c3134e38">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a9b4514beb5a17fa560faca26c3134e38">More...</a><br/></td></tr>
<tr class="separator:a9b4514beb5a17fa560faca26c3134e38 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a664d70addf3f701f1a62013c69355790">erase_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a664d70addf3f701f1a62013c69355790">More...</a><br/></td></tr>
<tr class="separator:a664d70addf3f701f1a62013c69355790 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a7036d8b2985726d5cb138c879d016a44">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set.  <a href="#a7036d8b2985726d5cb138c879d016a44">More...</a><br/></td></tr>
<tr class="separator:a7036d8b2985726d5cb138c879d016a44 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a213ba3e87c26e5a1afcc84e7cea477ad">erase_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a213ba3e87c26e5a1afcc84e7cea477ad">More...</a><br/></td></tr>
<tr class="separator:a213ba3e87c26e5a1afcc84e7cea477ad inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a578457cdff461f79ba9e57515d851b71">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a578457cdff461f79ba9e57515d851b71">More...</a><br/></td></tr>
<tr class="separator:a578457cdff461f79ba9e57515d851b71 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a783b11c482e9e855ec9d207262aefd75">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a783b11c482e9e855ec9d207262aefd75">More...</a><br/></td></tr>
<tr class="separator:a783b11c482e9e855ec9d207262aefd75 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac54aa700ea45175265ad3af45c4b8e35">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ac54aa700ea45175265ad3af45c4b8e35">More...</a><br/></td></tr>
<tr class="separator:ac54aa700ea45175265ad3af45c4b8e35 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a6571cfd080e66ed860360fe5bad2cd41">find_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a6571cfd080e66ed860360fe5bad2cd41">More...</a><br/></td></tr>
<tr class="separator:a6571cfd080e66ed860360fe5bad2cd41 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad6bf37c7669ff2d0cbe34df7f1f4a60d">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ad6bf37c7669ff2d0cbe34df7f1f4a60d">More...</a><br/></td></tr>
<tr class="separator:ad6bf37c7669ff2d0cbe34df7f1f4a60d inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a42d5afdd7bc075a28347a43c6ed6a067">find_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a42d5afdd7bc075a28347a43c6ed6a067">More...</a><br/></td></tr>
<tr class="separator:a42d5afdd7bc075a28347a43c6ed6a067 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#adc138e7fd59de4e6a8e0ce6fc13b3f20">clear</a> ()</td></tr>
<tr class="memdesc:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#adc138e7fd59de4e6a8e0ce6fc13b3f20">More...</a><br/></td></tr>
<tr class="separator:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Disposer &gt; </td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a23148d079b580ccc0a9141094b9534ee">clear_and_dispose</a> (Disposer oDisposer)</td></tr>
<tr class="memdesc:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="#a23148d079b580ccc0a9141094b9534ee">More...</a><br/></td></tr>
<tr class="separator:a23148d079b580ccc0a9141094b9534ee inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65734637d991285764dd94c663afab69 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a65734637d991285764dd94c663afab69">empty</a> () const </td></tr>
<tr class="memdesc:a65734637d991285764dd94c663afab69 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a65734637d991285764dd94c663afab69">More...</a><br/></td></tr>
<tr class="separator:a65734637d991285764dd94c663afab69 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77539c94df2fa452b5d15617c0b3cb2 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77539c94df2fa452b5d15617c0b3cb2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad77539c94df2fa452b5d15617c0b3cb2">size</a> () const </td></tr>
<tr class="memdesc:ad77539c94df2fa452b5d15617c0b3cb2 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:ad77539c94df2fa452b5d15617c0b3cb2 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ace0cf32a214311fb09204c86b0d2ff inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9ace0cf32a214311fb09204c86b0d2ff">bucket_count</a> () const </td></tr>
<tr class="memdesc:a9ace0cf32a214311fb09204c86b0d2ff inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a9ace0cf32a214311fb09204c86b0d2ff">More...</a><br/></td></tr>
<tr class="separator:a9ace0cf32a214311fb09204c86b0d2ff inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e8654c925669bf34f15bdb77dec065 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e8654c925669bf34f15bdb77dec065"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a28e8654c925669bf34f15bdb77dec065">lock_count</a> () const </td></tr>
<tr class="memdesc:a28e8654c925669bf34f15bdb77dec065 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br/></td></tr>
<tr class="separator:a28e8654c925669bf34f15bdb77dec065 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd9a9d0b05db9bbcd090b51e3e866af"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a09b825ee98486afcfc2ae03f0bef294f">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9bd9a9d0b05db9bbcd090b51e3e866af">statistics</a> () const </td></tr>
<tr class="memdesc:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4107eae58541683b5abc0c337d010c9 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4107eae58541683b5abc0c337d010c9"></a>
mutex_policy::statistics_type <br class="typebreak"/>
const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af4107eae58541683b5abc0c337d010c9">mutex_policy_statistics</a> () const </td></tr>
<tr class="memdesc:af4107eae58541683b5abc0c337d010c9 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br/></td></tr>
<tr class="separator:af4107eae58541683b5abc0c337d010c9 inherit pub_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:aec91125eaafeba9da642a4ec74fd7c0f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a></td></tr>
<tr class="memdesc:aec91125eaafeba9da642a4ec74fd7c0f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered  <a href="#aec91125eaafeba9da642a4ec74fd7c0f">More...</a><br/></td></tr>
<tr class="separator:aec91125eaafeba9da642a4ec74fd7c0f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57c3ed1e36757238a5396a667eeb06f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af57c3ed1e36757238a5396a667eeb06f"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> = hash::size</td></tr>
<tr class="memdesc:af57c3ed1e36757238a5396a667eeb06f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br/></td></tr>
<tr class="separator:af57c3ed1e36757238a5396a667eeb06f inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7428e959608e5decac221dc317e8da8 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7428e959608e5decac221dc317e8da8"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa7428e959608e5decac221dc317e8da8">c_nDefaultProbesetSize</a> = 4</td></tr>
<tr class="memdesc:aa7428e959608e5decac221dc317e8da8 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br/></td></tr>
<tr class="separator:aa7428e959608e5decac221dc317e8da8 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3b066d9b88fd5ec69263a5783ac17 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f3b066d9b88fd5ec69263a5783ac17"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a49f3b066d9b88fd5ec69263a5783ac17">c_nDefaultInitialSize</a> = 16</td></tr>
<tr class="memdesc:a49f3b066d9b88fd5ec69263a5783ac17 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br/></td></tr>
<tr class="separator:a49f3b066d9b88fd5ec69263a5783ac17 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb27b2754ff51b10ee5e7754aafec36 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb27b2754ff51b10ee5e7754aafec36"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aceb27b2754ff51b10ee5e7754aafec36">c_nRelocateLimit</a> = <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> * 2 - 1</td></tr>
<tr class="memdesc:aceb27b2754ff51b10ee5e7754aafec36 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br/></td></tr>
<tr class="separator:aceb27b2754ff51b10ee5e7754aafec36 inherit pub_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Traits = cuckoo::type_traits&gt;<br/>
class cds::container::CuckooSet&lt; T, Traits &gt;</h3>

<p>Cuckoo hash set. </p>
<p>Source</p>
<ul>
<li>[2007] M.Herlihy, N.Shavit, M.Tzafrir "Concurrent Cuckoo Hashing. Technical report"</li>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p><b>About Cuckoo hashing</b></p>
<p>[From "The Art of Multiprocessor Programming"] Cuckoo hashing is a hashing algorithm in which a newly added item displaces any earlier item occupying the same slot. For brevity, a table is a k-entry array of items. For a hash set f size N = 2k we use a two-entry array of tables, and two independent hash functions, <code> h0, h1: KeyRange -&gt; 0,...,k-1</code> mapping the set of possible keys to entries in he array. To test whether a value <code>x</code> is in the set, <code>find(x)</code> tests whether either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code> is equal to <code>x</code>. Similarly, <code>erase(x)</code>checks whether <code>x</code> is in either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code>, ad removes it if found.</p>
<p>The <code>insert(x)</code> successively "kicks out" conflicting items until every key has a slot. To add <code>x</code>, the method swaps <code>x</code> with <code>y</code>, the current occupant of <code>table[0][h0(x)]</code>. If the prior value was <code>NULL</code>, it is done. Otherwise, it swaps the newly nest-less value <code>y</code> for the current occupant of <code>table[1][h1(y)]</code> in the same way. As before, if the prior value was <code>NULL</code>, it is done. Otherwise, the method continues swapping entries (alternating tables) until it finds an empty slot. We might not find an empty slot, either because the table is full, or because the sequence of displacement forms a cycle. We therefore need an upper limit on the number of successive displacements we are willing to undertake. When this limit is exceeded, we resize the hash table, choose new hash functions and start over.</p>
<p>For concurrent cuckoo hashing, rather than organizing the set as a two-dimensional table of items, we use two-dimensional table of probe sets, where a probe set is a constant-sized set of items with the same hash code. Each probe set holds at most <code>PROBE_SIZE</code> items, but the algorithm tries to ensure that when the set is quiescent (i.e no method call in progress) each probe set holds no more than <code>THRESHOLD &lt; PROBE_SET</code> items. While method calls are in-flight, a probe set may temporarily hold more than <code>THRESHOLD</code> but never more than <code>PROBE_SET</code> items.</p>
<p>In current implementation, a probe set can be defined either as a (single-linked) list or as a fixed-sized vector, optionally ordered.</p>
<p>In description above two-table cuckoo hashing (<code>k = 2</code>) has been considered. We can generalize this approach for <code>k &gt;= 2</code> when we have <code>k</code> hash functions <code>h[0], ... h[k-1]</code> and <code>k</code> tables <code>table[0], ... table[k-1]</code>.</p>
<p>The search in probe set is linear, the complexity is <code> O(PROBE_SET) </code>. The probe set may be ordered or not. Ordered probe set can be a little better since the average search complexity is <code>O(PROBE_SET/2)</code>. However, the overhead of sorting can eliminate a gain of ordered search.</p>
<p>The probe set is ordered if <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is specified in <code>CuckooSet</code> declaration. Otherwise, the probe set is unordered and <code>CuckooSet</code> must contain <a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">opt::equal_to</a> option.</p>
<p>Template arguments:</p>
<ul>
<li><code>T</code> - the type stored in the set.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html" title="Type traits for CuckooSet and CuckooMap classes.">cuckoo::type_traits</a> for explanation. It is possible to declare option-based set with <a class="el" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cuckoo::make_traits</a> metafunction result as <code>Traits</code> template argument.</li>
</ul>
<p>Template argument list <code>Options</code>... of <a class="el" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cuckoo::make_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">opt::hash</a> - hash functor tuple, mandatory option. At least, two hash functors should be provided. All hash functor should be orthogonal (different): for each <code> i,j: i != j =&gt; h[i](x) != h[j](x) </code>. The hash functors are passed as <code> std::tuple&lt; H1, H2, ... Hn &gt; </code>. The number of hash functors specifies the number <code>k</code> - the count of hash tables in cuckoo hashing. If the compiler supports variadic templates then k is unlimited, otherwise up to 10 different hash functors are supported.</li>
<li><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a> - concurrent access policy. Available policies: <a class="el" href="classcds_1_1container_1_1cuckoo_1_1striping.html" title="Lock striping concurrent access policy. This is typedef for intrusive::cuckoo::striping template...">cuckoo::striping</a>, <a class="el" href="classcds_1_1container_1_1cuckoo_1_1refinable.html" title="Refinable concurrent access policy. This is typedef for intrusive::cuckoo::refinable template...">cuckoo::refinable</a>. Default is <a class="el" href="classcds_1_1container_1_1cuckoo_1_1striping.html" title="Lock striping concurrent access policy. This is typedef for intrusive::cuckoo::striping template...">cuckoo::striping</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">opt::equal_to</a> - key equality functor like <code>std::equal_to</code>. If this functor is defined then the probe-set will be unordered. If <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option is specified too, then the probe-set will be ordered and <a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">opt::equal_to</a> will be ignored.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> - key comparison functor. No default functor is provided. If the option is not specified, the <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is used. If <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option is specified, then the probe-set will be ordered.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> - specifies binary predicate used for key comparision. Default is <code>std::less&lt;T&gt;</code>. If <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option is specified, then the probe-set will be ordered.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1opt_1_1v_1_1sequential__item__counter.html">opt::v::sequential_item_counter</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - the allocator type using for allocating bucket tables. Default is <code>CDS_DEFAULT_ALLOCATOR</code> </li>
<li><a class="el" href="structcds_1_1opt_1_1node__allocator.html" title="[type-option] Option setter for node allocator">opt::node_allocator</a> - the allocator type using for allocating set's items. If this option is not specified then the type defined in <a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> option is used.</li>
<li><a class="el" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html" title="Option specifying whether to store hash values in the node.">cuckoo::store_hash</a> - this option reserves additional space in the node to store the hash value of the object once it's introduced in the container. When this option is used, the unordered container will store the calculated hash value in the node and rehashing operations won't need to recalculate the hash of the value. This option will improve the performance of unordered containers when rehashing is frequent or hashing the value is a slow operation. Default value is <code>false</code>.</li>
<li><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1probeset__type.html">cuckoo::probeset_type</a> - type of probe set, may be <code>cuckoo::list</code> or <code>cuckoo::vector&lt;Capacity&gt;</code>, Default is <code>cuckoo::list</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs">opt::stat</a> - internal statistics. Possibly types: <a class="el" href="classcds_1_1container_1_1cuckoo_1_1stat.html" title="Cuckoo statistics. This is typedef for intrusive::cuckoo::stat.">cuckoo::stat</a>, <a class="el" href="classcds_1_1container_1_1cuckoo_1_1empty__stat.html" title="Cuckoo empty statistics.This is typedef for intrusive::cuckoo::empty_stat.">cuckoo::empty_stat</a>. Default is <a class="el" href="classcds_1_1container_1_1cuckoo_1_1empty__stat.html" title="Cuckoo empty statistics.This is typedef for intrusive::cuckoo::empty_stat.">cuckoo::empty_stat</a></li>
</ul>
<p><b>Examples</b></p>
<p>Cuckoo-set with list-based unordered probe set and storing hash values </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_set.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Data stored in cuckoo set</span></div>
<div class="line"><span class="keyword">struct </span>my_data</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// key field</span></div>
<div class="line">    std::string     strKey  ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// other data</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Provide equal_to functor for my_data since we will use unordered probe-set</span></div>
<div class="line"><span class="keyword">struct </span>my_data_equal_to {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey ) == 0  ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s) == 0  ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey ) == 0   ;</div>
<div class="line">    }</div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Provide two hash functor for my_data</span></div>
<div class="line"><span class="keyword">struct </span>hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s ) ;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey ) ;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s))        ;</div>
<div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2)    ;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey ) ;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type traits</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html" title="Type traits for CuckooSet and CuckooMap classes.">cds::container::cuckoo::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> my_data_equa_to equal_to ;</div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a113c55c422ded6d8c897b8f59c12a640" title="hash functor tuple wrapped for internal use">hash</a> ;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = true ;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare CuckooSet type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html" title="Cuckoo hash set.">cds::container::CuckooSet&lt; my_data, my_traits &gt;</a> my_cuckoo_set ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equal option-based declaration</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html" title="Cuckoo hash set.">cds::container::CuckooSet</a>&lt; my_data,</div>
<div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cds::container::cuckoo::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for equal_to predicate">cds::opt::equal_to&lt; my_data_equal_to &gt;</a></div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html" title="Option specifying whether to store hash values in the node.">cds::container::cuckoo::store_hash&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; opt_cuckoo_set ;</div>
</div><!-- fragment --><p>If we provide <code>compare</code> function instead of <code>equal_to</code> for <code>my_data</code> we get as a result a cuckoo set with ordered probe set that may improve performance. Example for ordered vector-based probe-set:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_set.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Data stored in cuckoo set</span></div>
<div class="line"><span class="keyword">struct </span>my_data</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// key field</span></div>
<div class="line">    std::string     strKey  ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// other data</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Provide compare functor for my_data since we want to use ordered probe-set</span></div>
<div class="line"><span class="keyword">struct </span>my_data_compare {</div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey )  ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s)  ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey )    ;</div>
<div class="line">    }</div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Provide two hash functor for my_data</span></div>
<div class="line"><span class="keyword">struct </span>hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s ) ;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey ) ;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s))        ;</div>
<div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2)    ;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey ) ;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type traits</span></div>
<div class="line"><span class="comment">// We use a vector of capacity 4 as probe-set container and store hash values in the node</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1type__traits.html" title="Type traits for CuckooSet and CuckooMap classes.">cds::container::cuckoo::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> my_data_compare compare ;</div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a113c55c422ded6d8c897b8f59c12a640" title="hash functor tuple wrapped for internal use">hash</a> ;</div>
<div class="line">    <span class="keyword">typedef</span> cds::container::cuckoo::vector&lt;4&gt; probeset_type ;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = true ;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare CuckooSet type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html" title="Cuckoo hash set.">cds::container::CuckooSet&lt; my_data, my_traits &gt;</a> my_cuckoo_set ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equal option-based declaration</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html" title="Cuckoo hash set.">cds::container::CuckooSet</a>&lt; my_data,</div>
<div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits.">cds::container::cuckoo::make_traits</a>&lt;</div>
<div class="line">        cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt; &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::opt::compare&lt; my_data_compare &gt;</a></div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1probeset__type.html" title="Probe set type option.">cds::container::cuckoo::probeset_type&lt; cds::container::cuckoo::vector&lt;4&gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html" title="Option specifying whether to store hash values in the node.">cds::container::cuckoo::store_hash&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; opt_cuckoo_set ;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1101460328fbacaf3bdc4acd5c0e81e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initial size = <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a></p>
<p>Probe set size:</p>
<ul>
<li><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a029af01b7f4957161b5d1852f8deb22e">c_nDefaultProbesetSize</a> if <code>probeset_type</code> is <code>cuckoo::list</code> </li>
<li><code>Capacity</code> if <code>probeset_type</code> is <code> cuckoo::vector&lt;Capacity&gt; </code></li>
</ul>
<p>Probe set threshold = probe set size - 1 </p>

</div>
</div>
<a class="anchor" id="a9ba8f1383336b8f15853911a4414cb3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set size and threshold. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a296b3dacd480c537a3775a04166d19e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given hash functor tuple. </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1101460328fbacaf3bdc4acd5c0e81e7" title="Default constructor.">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafbb45c6bf31fd741fa17f3af1edaca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set properties and hash functor tuple. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa907edd06474f7cc1d153b35c7747c5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given hash functor tuple (move semantics) </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1101460328fbacaf3bdc4acd5c0e81e7" title="Default constructor.">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aa844c23eee0a1f388f732477483b33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set properties and hash functor tuple (move semantics) </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5bbaf1e626c8490383f6799f741d1476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a class="anchor" id="a17a224c06b767df1f39e5eb7fb3625a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set. </p>
<p>The function erases all items from the set. </p>

</div>
</div>
<a class="anchor" id="ac8b66db35b6bd7b25b22b6cab8f84795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>This function is available only for compiler that supports variadic template and move semantics </p>

</div>
</div>
<a class="anchor" id="a346358bcaee9005b34cabdfa7e2db675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>

</div>
</div>
<a class="anchor" id="a10d5d2327524b39acb641eaa26f82762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>val</code> exists in the set. </p>
<p>The operation performs inserting or changing data.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> should be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf" title="value type stored in the container">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf" title="value type stored in the container">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code> function</li>
</ul>
<p>The functor can change non-key fields of the <code>item</code>.</p>
<p>You can pass <code>func</code> argument by value or by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>val</code> key already exists. </p>

</div>
</div>
<a class="anchor" id="a600a2a1f6dee844efa7732c9c37fdbe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_erase"></a> Since the key of set's item type <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The set item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="ae087593ff478f76db232f7e6ba664e2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf" title="value type stored in the container">value_type</a> <span class="keyword">const</span>&amp; val) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor can be passed by value or by reference using <code>boost:ref</code></p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a1cb6ddf92a91d5aa73758d4dd78b03a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_erase">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. If cuckoo set is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo set is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a class="anchor" id="a0e746d9a12ec6a109364f57383296b9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a class="anchor" id="a8bc2faf556b0509b97dc9f45ca0ca814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf" title="value type stored in the container">value_type</a>&amp; item, Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You can pass <code>f</code> argument by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor can change non-key fields of <code>item</code>. The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>The type <code>Q</code> can differ from <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> of items storing in the container. Therefore, the <code>value_type</code> should be comparable with type <code>Q</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ad82fa75613e410f6f66ec78ebd0297ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_find_cfunc"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf" title="value type stored in the container">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You can pass <code>f</code> argument by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor can change non-key fields of <code>item</code>.</p>
<p>The type <code>Q</code> can differ from <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> of items storing in the container. Therefore, the <code>value_type</code> should be comparable with type <code>Q</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a56a4214ffabbf30fa6529ac127258728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_find_val"></a> The function searches the item with key equal to <code>val</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a>. </p>

</div>
</div>
<a class="anchor" id="a90bf720dc7a1496938965d5c3ae9a090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a0bd375dd6a59a0e6a75452b66c235b34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ac02400da123bb6831b3b1c1d47c3766e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a31094d63170ecc65adfba66f838e4736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aabf139c50172cf26e3d94a7c7141c562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of new item .</li>
</ul>
<p>The functor signature is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf" title="value type stored in the container">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> where <code>item</code> is the item inserted.</p>
<p>The type <code>Q</code> can differ from <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> of items storing in the set. Therefore, the <code>value_type</code> should be constructible from type <code>Q</code>.</p>
<p>The user-defined functor is called only if the inserting is success. It can be passed by reference using <code>boost::ref</code> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/cuckoo_set.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:55 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
