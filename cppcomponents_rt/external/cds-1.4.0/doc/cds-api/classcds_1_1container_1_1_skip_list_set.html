<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::SkipListSet&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html">SkipListSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SkipListSet&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free skip-list set.  
 <a href="classcds_1_1container_1_1_skip_list_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/skip_list_set_impl.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SkipListSet&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_skip_list_set.png" usemap="#cds::container::SkipListSet&lt; GC, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::SkipListSet&lt; GC, T, Traits &gt;_map" name="cds::container::SkipListSet&lt; GC, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_skip_list_set.html" title="Lock-free skip-list set." alt="cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;" shape="rect" coords="0,0,256,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e44431d3033235e9382dacc40c9b4e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e44431d3033235e9382dacc40c9b4e3"></a>
typedef base_class::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9e44431d3033235e9382dacc40c9b4e3">gc</a></td></tr>
<tr class="memdesc:a9e44431d3033235e9382dacc40c9b4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br/></td></tr>
<tr class="separator:a9e44431d3033235e9382dacc40c9b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bae06c446486a883e3bf8cd9c65950d"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a></td></tr>
<tr class="separator:a9bae06c446486a883e3bf8cd9c65950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714db662d85d19dacffbcedd5c172bfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a714db662d85d19dacffbcedd5c172bfe"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a714db662d85d19dacffbcedd5c172bfe">options</a></td></tr>
<tr class="memdesc:a714db662d85d19dacffbcedd5c172bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options specified. <br/></td></tr>
<tr class="separator:a714db662d85d19dacffbcedd5c172bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648f26d3fa2a526f4bd41faafc70ea69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a648f26d3fa2a526f4bd41faafc70ea69"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a648f26d3fa2a526f4bd41faafc70ea69">back_off</a></td></tr>
<tr class="memdesc:a648f26d3fa2a526f4bd41faafc70ea69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy used. <br/></td></tr>
<tr class="separator:a648f26d3fa2a526f4bd41faafc70ea69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d331c252fa5fed4a05f2c13b2f612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac60d331c252fa5fed4a05f2c13b2f612"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#ac60d331c252fa5fed4a05f2c13b2f612">allocator_type</a></td></tr>
<tr class="memdesc:ac60d331c252fa5fed4a05f2c13b2f612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate the skip-list nodes. <br/></td></tr>
<tr class="separator:ac60d331c252fa5fed4a05f2c13b2f612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e0a522b53a52e02b3f3490b91567f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e0a522b53a52e02b3f3490b91567f8"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a60e0a522b53a52e02b3f3490b91567f8">item_counter</a></td></tr>
<tr class="memdesc:a60e0a522b53a52e02b3f3490b91567f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a60e0a522b53a52e02b3f3490b91567f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4f0530a3e75b25503aa1764b85cec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bd4f0530a3e75b25503aa1764b85cec"></a>
typedef maker::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a8bd4f0530a3e75b25503aa1764b85cec">key_comparator</a></td></tr>
<tr class="memdesc:a8bd4f0530a3e75b25503aa1764b85cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparision functor <br/></td></tr>
<tr class="separator:a8bd4f0530a3e75b25503aa1764b85cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb13db4d40eefa97680c6b2776c586cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb13db4d40eefa97680c6b2776c586cb"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#adb13db4d40eefa97680c6b2776c586cb">memory_model</a></td></tr>
<tr class="memdesc:adb13db4d40eefa97680c6b2776c586cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:adb13db4d40eefa97680c6b2776c586cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb5033075d007eca960f1baf6b969ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb5033075d007eca960f1baf6b969ef"></a>
typedef <br class="typebreak"/>
options::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a7eb5033075d007eca960f1baf6b969ef">random_level_generator</a></td></tr>
<tr class="memdesc:a7eb5033075d007eca960f1baf6b969ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br/></td></tr>
<tr class="separator:a7eb5033075d007eca960f1baf6b969ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a416503e36e27f5abca3e64a3f8d42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80a416503e36e27f5abca3e64a3f8d42"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a80a416503e36e27f5abca3e64a3f8d42">stat</a></td></tr>
<tr class="memdesc:a80a416503e36e27f5abca3e64a3f8d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a80a416503e36e27f5abca3e64a3f8d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb219352dd6491a5efac6dd0b924a5fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb219352dd6491a5efac6dd0b924a5fd"></a>
typedef <br class="typebreak"/>
skip_list::details::iterator<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
base_class::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a></td></tr>
<tr class="memdesc:abb219352dd6491a5efac6dd0b924a5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br/></td></tr>
<tr class="separator:abb219352dd6491a5efac6dd0b924a5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd31d37191b0182f57e887790753e3bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd31d37191b0182f57e887790753e3bb"></a>
typedef <br class="typebreak"/>
skip_list::details::iterator<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
base_class::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a></td></tr>
<tr class="memdesc:acd31d37191b0182f57e887790753e3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br/></td></tr>
<tr class="separator:acd31d37191b0182f57e887790753e3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7835f9284e72b8e4b6b2e7825cfeef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7835f9284e72b8e4b6b2e7825cfeef8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#ab7835f9284e72b8e4b6b2e7825cfeef8">SkipListSet</a> ()</td></tr>
<tr class="memdesc:ab7835f9284e72b8e4b6b2e7825cfeef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. <br/></td></tr>
<tr class="separator:ab7835f9284e72b8e4b6b2e7825cfeef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cec296de8b05a21cd626f8c0811def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cec296de8b05a21cd626f8c0811def"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a41cec296de8b05a21cd626f8c0811def">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:a41cec296de8b05a21cd626f8c0811def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys the set object. <br/></td></tr>
<tr class="separator:a41cec296de8b05a21cd626f8c0811def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0abb2d62d736d13083778e5ca3fe6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dd0abb2d62d736d13083778e5ca3fe6"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a3dd0abb2d62d736d13083778e5ca3fe6">begin</a> ()</td></tr>
<tr class="memdesc:a3dd0abb2d62d736d13083778e5ca3fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a3dd0abb2d62d736d13083778e5ca3fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35161588bd79205c81b84919c7722c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a35161588bd79205c81b84919c7722c"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a2a35161588bd79205c81b84919c7722c">end</a> ()</td></tr>
<tr class="memdesc:a2a35161588bd79205c81b84919c7722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:a2a35161588bd79205c81b84919c7722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e9f24060a29d05a775108a323b804b"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a58e9f24060a29d05a775108a323b804b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a58e9f24060a29d05a775108a323b804b">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a58e9f24060a29d05a775108a323b804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a58e9f24060a29d05a775108a323b804b">More...</a><br/></td></tr>
<tr class="separator:a58e9f24060a29d05a775108a323b804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a4f437617d9f9b09b0fc6358b3471bbe3">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4f437617d9f9b09b0fc6358b3471bbe3">More...</a><br/></td></tr>
<tr class="separator:a4f437617d9f9b09b0fc6358b3471bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28831477fa76661cfeb2fe4884ef025c"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a28831477fa76661cfeb2fe4884ef025c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a28831477fa76661cfeb2fe4884ef025c">ensure</a> (const Q &amp;val, Func func)</td></tr>
<tr class="memdesc:a28831477fa76661cfeb2fe4884ef025c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the item exists in the set.  <a href="#a28831477fa76661cfeb2fe4884ef025c">More...</a><br/></td></tr>
<tr class="separator:a28831477fa76661cfeb2fe4884ef025c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#adb97ed3e2b3a677fb0a9abbf9025477e">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_containewr_SkipListSet_value_type">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#adb97ed3e2b3a677fb0a9abbf9025477e">More...</a><br/></td></tr>
<tr class="separator:adb97ed3e2b3a677fb0a9abbf9025477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9c4e9e93f23fe55fc1a13c0998dc2267">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a9c4e9e93f23fe55fc1a13c0998dc2267">More...</a><br/></td></tr>
<tr class="separator:a9c4e9e93f23fe55fc1a13c0998dc2267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52388afd06ea35ed1cbd785dba52ac0f"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a52388afd06ea35ed1cbd785dba52ac0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a52388afd06ea35ed1cbd785dba52ac0f">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a52388afd06ea35ed1cbd785dba52ac0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a52388afd06ea35ed1cbd785dba52ac0f">More...</a><br/></td></tr>
<tr class="separator:a52388afd06ea35ed1cbd785dba52ac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#aa2542991a0a9f2348c9b6c5cca0ae1a1">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#aa2542991a0a9f2348c9b6c5cca0ae1a1">More...</a><br/></td></tr>
<tr class="separator:aa2542991a0a9f2348c9b6c5cca0ae1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bf176ad8950298a770a801f5bd68bb"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ae6bf176ad8950298a770a801f5bd68bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#ae6bf176ad8950298a770a801f5bd68bb">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ae6bf176ad8950298a770a801f5bd68bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ae6bf176ad8950298a770a801f5bd68bb">More...</a><br/></td></tr>
<tr class="separator:ae6bf176ad8950298a770a801f5bd68bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398387430b5fb2c32a984cdbbc5ba18"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a9398387430b5fb2c32a984cdbbc5ba18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9398387430b5fb2c32a984cdbbc5ba18">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a9398387430b5fb2c32a984cdbbc5ba18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a9398387430b5fb2c32a984cdbbc5ba18">More...</a><br/></td></tr>
<tr class="separator:a9398387430b5fb2c32a984cdbbc5ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c073e8eff04b69d9365430a999f54a2"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a1c073e8eff04b69d9365430a999f54a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a1c073e8eff04b69d9365430a999f54a2">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a1c073e8eff04b69d9365430a999f54a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a1c073e8eff04b69d9365430a999f54a2">More...</a><br/></td></tr>
<tr class="separator:a1c073e8eff04b69d9365430a999f54a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d2550d0cd568858090c90691469639"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a53d2550d0cd568858090c90691469639"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a53d2550d0cd568858090c90691469639">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a53d2550d0cd568858090c90691469639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a53d2550d0cd568858090c90691469639">More...</a><br/></td></tr>
<tr class="separator:a53d2550d0cd568858090c90691469639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d30aff076102810e08f274eb64776e"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a02d30aff076102810e08f274eb64776e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a02d30aff076102810e08f274eb64776e">find_with</a> (Q const &amp;val, Less cmp, Func f)</td></tr>
<tr class="memdesc:a02d30aff076102810e08f274eb64776e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a02d30aff076102810e08f274eb64776e">More...</a><br/></td></tr>
<tr class="separator:a02d30aff076102810e08f274eb64776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac835b244b8917e33d8883337fb632134"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac835b244b8917e33d8883337fb632134"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#ac835b244b8917e33d8883337fb632134">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:ac835b244b8917e33d8883337fb632134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ac835b244b8917e33d8883337fb632134">More...</a><br/></td></tr>
<tr class="separator:ac835b244b8917e33d8883337fb632134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60b6abe7a7f5a48a583817153f5b159"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ae60b6abe7a7f5a48a583817153f5b159"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#ae60b6abe7a7f5a48a583817153f5b159">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:ae60b6abe7a7f5a48a583817153f5b159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#ae60b6abe7a7f5a48a583817153f5b159">More...</a><br/></td></tr>
<tr class="separator:ae60b6abe7a7f5a48a583817153f5b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3b2f71972becaa6a28de52ef3956bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a2f3b2f71972becaa6a28de52ef3956bc">clear</a> ()</td></tr>
<tr class="memdesc:a2f3b2f71972becaa6a28de52ef3956bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic).  <a href="#a2f3b2f71972becaa6a28de52ef3956bc">More...</a><br/></td></tr>
<tr class="separator:a2f3b2f71972becaa6a28de52ef3956bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6994d9dcb9b7fb2b339833107efceaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6994d9dcb9b7fb2b339833107efceaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#af6994d9dcb9b7fb2b339833107efceaf">empty</a> () const </td></tr>
<tr class="memdesc:af6994d9dcb9b7fb2b339833107efceaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br/></td></tr>
<tr class="separator:af6994d9dcb9b7fb2b339833107efceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfdb785d05781a79097c8d289392ae6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a3cfdb785d05781a79097c8d289392ae6">size</a> () const </td></tr>
<tr class="memdesc:a3cfdb785d05781a79097c8d289392ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#a3cfdb785d05781a79097c8d289392ae6">More...</a><br/></td></tr>
<tr class="separator:a3cfdb785d05781a79097c8d289392ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f1bca5f4a30ebe761f6ded4234451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170f1bca5f4a30ebe761f6ded4234451"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a80a416503e36e27f5abca3e64a3f8d42">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a170f1bca5f4a30ebe761f6ded4234451">statistics</a> () const </td></tr>
<tr class="memdesc:a170f1bca5f4a30ebe761f6ded4234451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a170f1bca5f4a30ebe761f6ded4234451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac2f7bb4aa7bf1087f0d0f8ee81714685"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f7bb4aa7bf1087f0d0f8ee81714685"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#ac2f7bb4aa7bf1087f0d0f8ee81714685">begin</a> () const </td></tr>
<tr class="memdesc:ac2f7bb4aa7bf1087f0d0f8ee81714685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:ac2f7bb4aa7bf1087f0d0f8ee81714685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62969eea044308169813d252e376f7c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62969eea044308169813d252e376f7c2"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> ()</td></tr>
<tr class="separator:a62969eea044308169813d252e376f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afd68b139c37edcc6da3bb52bbd289fdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd68b139c37edcc6da3bb52bbd289fdb"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_set.html#afd68b139c37edcc6da3bb52bbd289fdb">end</a> () const </td></tr>
<tr class="memdesc:afd68b139c37edcc6da3bb52bbd289fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:afd68b139c37edcc6da3bb52bbd289fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2ba5bb86429076eb66462ae821ff8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a2ba5bb86429076eb66462ae821ff8c"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> ()</td></tr>
<tr class="separator:a3a2ba5bb86429076eb66462ae821ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a56e97287193c265e405565645f3f3809 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56e97287193c265e405565645f3f3809"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a></td></tr>
<tr class="memdesc:a56e97287193c265e405565645f3f3809 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the skip-list <br/></td></tr>
<tr class="separator:a56e97287193c265e405565645f3f3809 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef3d23d49683e4ed3a8542b338f4987 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ef3d23d49683e4ed3a8542b338f4987"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7ef3d23d49683e4ed3a8542b338f4987">options</a></td></tr>
<tr class="memdesc:a7ef3d23d49683e4ed3a8542b338f4987 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:a7ef3d23d49683e4ed3a8542b338f4987 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed56fc3e629fc86cb87aaa63f2184b7 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ed56fc3e629fc86cb87aaa63f2184b7"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8ed56fc3e629fc86cb87aaa63f2184b7">hook</a></td></tr>
<tr class="memdesc:a8ed56fc3e629fc86cb87aaa63f2184b7 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:a8ed56fc3e629fc86cb87aaa63f2184b7 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c111410605d85dee2daf622820e34 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1c111410605d85dee2daf622820e34"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a></td></tr>
<tr class="memdesc:aeb1c111410605d85dee2daf622820e34 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:aeb1c111410605d85dee2daf622820e34 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4549fb15869b93cf05194c65fed873 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4549fb15869b93cf05194c65fed873"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3f4549fb15869b93cf05194c65fed873">key_comparator</a></td></tr>
<tr class="memdesc:a3f4549fb15869b93cf05194c65fed873 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparision functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:a3f4549fb15869b93cf05194c65fed873 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1447aba41ff3e49a9b7576efa7414 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d1447aba41ff3e49a9b7576efa7414"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ab6d1447aba41ff3e49a9b7576efa7414">disposer</a></td></tr>
<tr class="memdesc:ab6d1447aba41ff3e49a9b7576efa7414 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer used <br/></td></tr>
<tr class="separator:ab6d1447aba41ff3e49a9b7576efa7414 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c65a30daf01ebe2e7c365f01d1129 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada7c65a30daf01ebe2e7c365f01d1129"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8ed56fc3e629fc86cb87aaa63f2184b7">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a></td></tr>
<tr class="memdesc:ada7c65a30daf01ebe2e7c365f01d1129 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br/></td></tr>
<tr class="separator:ada7c65a30daf01ebe2e7c365f01d1129 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ea0b7fdd8c0e6796409fce834305e inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121ea0b7fdd8c0e6796409fce834305e"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a></td></tr>
<tr class="memdesc:a121ea0b7fdd8c0e6796409fce834305e inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:a121ea0b7fdd8c0e6796409fce834305e inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e6272268d1b060bc3556bf578e9b3f inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96e6272268d1b060bc3556bf578e9b3f"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a96e6272268d1b060bc3556bf578e9b3f">item_counter</a></td></tr>
<tr class="memdesc:a96e6272268d1b060bc3556bf578e9b3f inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a96e6272268d1b060bc3556bf578e9b3f inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77e6633bb733e07f44ec1cf76fae465 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77e6633bb733e07f44ec1cf76fae465"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae77e6633bb733e07f44ec1cf76fae465">memory_model</a></td></tr>
<tr class="memdesc:ae77e6633bb733e07f44ec1cf76fae465 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:ae77e6633bb733e07f44ec1cf76fae465 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0388fcf5210ad06265147f31a2123e0 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0388fcf5210ad06265147f31a2123e0"></a>
typedef <br class="typebreak"/>
options::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ac0388fcf5210ad06265147f31a2123e0">random_level_generator</a></td></tr>
<tr class="memdesc:ac0388fcf5210ad06265147f31a2123e0 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br/></td></tr>
<tr class="separator:ac0388fcf5210ad06265147f31a2123e0 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80deb2cfd0b815ad5b43b9bdf20c9f4a inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80deb2cfd0b815ad5b43b9bdf20c9f4a"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a80deb2cfd0b815ad5b43b9bdf20c9f4a">allocator_type</a></td></tr>
<tr class="memdesc:a80deb2cfd0b815ad5b43b9bdf20c9f4a inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining array of next pointers of the node <br/></td></tr>
<tr class="separator:a80deb2cfd0b815ad5b43b9bdf20c9f4a inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a39ca7054fa25e993495b5ff5dc4d inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a103a39ca7054fa25e993495b5ff5dc4d"></a>
typedef options::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a103a39ca7054fa25e993495b5ff5dc4d">back_off</a></td></tr>
<tr class="memdesc:a103a39ca7054fa25e993495b5ff5dc4d inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off trategy. <br/></td></tr>
<tr class="separator:a103a39ca7054fa25e993495b5ff5dc4d inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c392aaa698e650691dabb0ea5ddc67c inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c392aaa698e650691dabb0ea5ddc67c"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c392aaa698e650691dabb0ea5ddc67c">stat</a></td></tr>
<tr class="memdesc:a6c392aaa698e650691dabb0ea5ddc67c inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a6c392aaa698e650691dabb0ea5ddc67c inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5837aaa0b5d7e47b3df0b13c66ed4f"></a>
typedef <br class="typebreak"/>
skip_list::details::iterator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a103a39ca7054fa25e993495b5ff5dc4d">back_off</a>, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a></td></tr>
<tr class="memdesc:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br/></td></tr>
<tr class="separator:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadf8dabaa6f1f1bacee706f8c71e0896"></a>
typedef <br class="typebreak"/>
skip_list::details::iterator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a103a39ca7054fa25e993495b5ff5dc4d">back_off</a>, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a></td></tr>
<tr class="memdesc:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br/></td></tr>
<tr class="separator:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pub_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab687ac3a8e557334e59f7b0373b70f0d"></a>
typedef <br class="typebreak"/>
node_type::atomic_marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ab687ac3a8e557334e59f7b0373b70f0d">atomic_node_ptr</a></td></tr>
<tr class="memdesc:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic marked node pointer. <br/></td></tr>
<tr class="separator:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c805bcce3eb95b1fc81ed212a90b3c5"></a>
typedef node_type::marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8c805bcce3eb95b1fc81ed212a90b3c5">marked_node_ptr</a></td></tr>
<tr class="memdesc:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node marked pointer. <br/></td></tr>
<tr class="separator:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:ae919ad1a045a397fda269e2c2924b818 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae919ad1a045a397fda269e2c2924b818">SkipListSet</a> ()</td></tr>
<tr class="memdesc:ae919ad1a045a397fda269e2c2924b818 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae919ad1a045a397fda269e2c2924b818">More...</a><br/></td></tr>
<tr class="separator:ae919ad1a045a397fda269e2c2924b818 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71bc587ae2e26e0fb5aae6fbc155e3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa71bc587ae2e26e0fb5aae6fbc155e3f">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and destructs the skip-list. <br/></td></tr>
<tr class="separator:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b00185809fb7842667287ed4a2ee0c2 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b00185809fb7842667287ed4a2ee0c2"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a4b00185809fb7842667287ed4a2ee0c2">begin</a> ()</td></tr>
<tr class="memdesc:a4b00185809fb7842667287ed4a2ee0c2 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a4b00185809fb7842667287ed4a2ee0c2 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af350224256d13022cc13025597668139 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af350224256d13022cc13025597668139"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#af350224256d13022cc13025597668139">end</a> ()</td></tr>
<tr class="memdesc:af350224256d13022cc13025597668139 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:af350224256d13022cc13025597668139 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51afff99d91ece7435020b6715697b91 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a51afff99d91ece7435020b6715697b91">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a51afff99d91ece7435020b6715697b91 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a51afff99d91ece7435020b6715697b91">More...</a><br/></td></tr>
<tr class="separator:a51afff99d91ece7435020b6715697b91 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cce1422756e1f63a84f67c5a78d9553 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a8cce1422756e1f63a84f67c5a78d9553 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8cce1422756e1f63a84f67c5a78d9553">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a8cce1422756e1f63a84f67c5a78d9553 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a8cce1422756e1f63a84f67c5a78d9553">More...</a><br/></td></tr>
<tr class="separator:a8cce1422756e1f63a84f67c5a78d9553 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff093722108876219c6210d7e730fd25 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aff093722108876219c6210d7e730fd25 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aff093722108876219c6210d7e730fd25">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:aff093722108876219c6210d7e730fd25 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#aff093722108876219c6210d7e730fd25">More...</a><br/></td></tr>
<tr class="separator:aff093722108876219c6210d7e730fd25 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0561887682f47f5358170b6a87ca18 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c0561887682f47f5358170b6a87ca18">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a6c0561887682f47f5358170b6a87ca18 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="#a6c0561887682f47f5358170b6a87ca18">More...</a><br/></td></tr>
<tr class="separator:a6c0561887682f47f5358170b6a87ca18 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef0b00badd62f519e88fca726ef6a4a inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aaef0b00badd62f519e88fca726ef6a4a inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aaef0b00badd62f519e88fca726ef6a4a">erase</a> (const Q &amp;val)</td></tr>
<tr class="memdesc:aaef0b00badd62f519e88fca726ef6a4a inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#aaef0b00badd62f519e88fca726ef6a4a">More...</a><br/></td></tr>
<tr class="separator:aaef0b00badd62f519e88fca726ef6a4a inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533b40771734853dc7758fdd95a4dd8e inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a533b40771734853dc7758fdd95a4dd8e inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a533b40771734853dc7758fdd95a4dd8e">erase_with</a> (const Q &amp;val, Less pred)</td></tr>
<tr class="memdesc:a533b40771734853dc7758fdd95a4dd8e inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#a533b40771734853dc7758fdd95a4dd8e">More...</a><br/></td></tr>
<tr class="separator:a533b40771734853dc7758fdd95a4dd8e inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d0ce66d2630bdaf6d3f0c09a2187c7 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae4d0ce66d2630bdaf6d3f0c09a2187c7 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae4d0ce66d2630bdaf6d3f0c09a2187c7">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ae4d0ce66d2630bdaf6d3f0c09a2187c7 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#ae4d0ce66d2630bdaf6d3f0c09a2187c7">More...</a><br/></td></tr>
<tr class="separator:ae4d0ce66d2630bdaf6d3f0c09a2187c7 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200e5876eef48fb1cd62e825201c9f3 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ae200e5876eef48fb1cd62e825201c9f3 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae200e5876eef48fb1cd62e825201c9f3">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ae200e5876eef48fb1cd62e825201c9f3 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#ae200e5876eef48fb1cd62e825201c9f3">More...</a><br/></td></tr>
<tr class="separator:ae200e5876eef48fb1cd62e825201c9f3 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11344b0767e13aac9f37b7f6c4f1cebf inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a11344b0767e13aac9f37b7f6c4f1cebf inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a11344b0767e13aac9f37b7f6c4f1cebf">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a11344b0767e13aac9f37b7f6c4f1cebf inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a11344b0767e13aac9f37b7f6c4f1cebf">More...</a><br/></td></tr>
<tr class="separator:a11344b0767e13aac9f37b7f6c4f1cebf inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e938de8272b88a726ce92fa0ae6f6ec inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a0e938de8272b88a726ce92fa0ae6f6ec inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a0e938de8272b88a726ce92fa0ae6f6ec">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a0e938de8272b88a726ce92fa0ae6f6ec inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with <code>pred</code> predicate for comparing.  <a href="#a0e938de8272b88a726ce92fa0ae6f6ec">More...</a><br/></td></tr>
<tr class="separator:a0e938de8272b88a726ce92fa0ae6f6ec inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936578aef7cd9fd31be1cc96d0b6f089 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a936578aef7cd9fd31be1cc96d0b6f089 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a936578aef7cd9fd31be1cc96d0b6f089">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a936578aef7cd9fd31be1cc96d0b6f089 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a936578aef7cd9fd31be1cc96d0b6f089">More...</a><br/></td></tr>
<tr class="separator:a936578aef7cd9fd31be1cc96d0b6f089 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4445d6e97ab8c2b01d0f23663962fa05 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a4445d6e97ab8c2b01d0f23663962fa05 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a4445d6e97ab8c2b01d0f23663962fa05">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a4445d6e97ab8c2b01d0f23663962fa05 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with <code>pred</code> predicate for comparing.  <a href="#a4445d6e97ab8c2b01d0f23663962fa05">More...</a><br/></td></tr>
<tr class="separator:a4445d6e97ab8c2b01d0f23663962fa05 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9413908a1e25ea72c35d8a6fc25ca53 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac9413908a1e25ea72c35d8a6fc25ca53 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ac9413908a1e25ea72c35d8a6fc25ca53">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:ac9413908a1e25ea72c35d8a6fc25ca53 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#ac9413908a1e25ea72c35d8a6fc25ca53">More...</a><br/></td></tr>
<tr class="separator:ac9413908a1e25ea72c35d8a6fc25ca53 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34be052fa6b274be9711f4099326d33 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ab34be052fa6b274be9711f4099326d33 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ab34be052fa6b274be9711f4099326d33">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:ab34be052fa6b274be9711f4099326d33 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#ab34be052fa6b274be9711f4099326d33">More...</a><br/></td></tr>
<tr class="separator:ab34be052fa6b274be9711f4099326d33 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43241fb0c5805c1e2358695d29bbb8aa inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a43241fb0c5805c1e2358695d29bbb8aa">size</a> () const </td></tr>
<tr class="memdesc:a43241fb0c5805c1e2358695d29bbb8aa inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#a43241fb0c5805c1e2358695d29bbb8aa">More...</a><br/></td></tr>
<tr class="separator:a43241fb0c5805c1e2358695d29bbb8aa inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee308a445474535e243b8aed0c804eb8 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee308a445474535e243b8aed0c804eb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aee308a445474535e243b8aed0c804eb8">empty</a> () const </td></tr>
<tr class="memdesc:aee308a445474535e243b8aed0c804eb8 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br/></td></tr>
<tr class="separator:aee308a445474535e243b8aed0c804eb8 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28947a855f1e0e702da233287eb3c59f inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a28947a855f1e0e702da233287eb3c59f">clear</a> ()</td></tr>
<tr class="memdesc:a28947a855f1e0e702da233287eb3c59f inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a28947a855f1e0e702da233287eb3c59f">More...</a><br/></td></tr>
<tr class="separator:a28947a855f1e0e702da233287eb3c59f inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506ebd8ef00f13f16656c2d7289e318 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7506ebd8ef00f13f16656c2d7289e318"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c392aaa698e650691dabb0ea5ddc67c">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7506ebd8ef00f13f16656c2d7289e318">statistics</a> () const </td></tr>
<tr class="memdesc:a7506ebd8ef00f13f16656c2d7289e318 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a7506ebd8ef00f13f16656c2d7289e318 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5713f69c26a9ad3de006438c59719bd9 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5713f69c26a9ad3de006438c59719bd9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a5713f69c26a9ad3de006438c59719bd9">begin</a> () const </td></tr>
<tr class="memdesc:a5713f69c26a9ad3de006438c59719bd9 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a5713f69c26a9ad3de006438c59719bd9 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3923f4377394d7a5745446df6bdced inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3923f4377394d7a5745446df6bdced"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> ()</td></tr>
<tr class="separator:ace3923f4377394d7a5745446df6bdced inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774669f3df983ed43dac9c1836324d71 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a774669f3df983ed43dac9c1836324d71"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a774669f3df983ed43dac9c1836324d71">end</a> () const </td></tr>
<tr class="memdesc:a774669f3df983ed43dac9c1836324d71 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:a774669f3df983ed43dac9c1836324d71 inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71370d3b11465af88eecac90f768ccb inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac71370d3b11465af88eecac90f768ccb"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> ()</td></tr>
<tr class="separator:ac71370d3b11465af88eecac90f768ccb inherit pub_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pub_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a891742e136dd2a31a2bdc80ecfdf73f4"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a891742e136dd2a31a2bdc80ecfdf73f4">max_height</a> () noexcept()</td></tr>
<tr class="memdesc:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pub_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum height of skip-list. The max height is a constant for each object and does not exceed 32. <br/></td></tr>
<tr class="separator:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pub_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pub_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a92a0f389d6be4dd2dc2ea005aa49e79e">c_nMaxHeight</a></td></tr>
<tr class="memdesc:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pub_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code>  <a href="#a92a0f389d6be4dd2dc2ea005aa49e79e">More...</a><br/></td></tr>
<tr class="separator:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pub_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt;<br/>
class cds::container::SkipListSet&lt; GC, T, Traits &gt;</h3>

<p>Lock-free skip-list set. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_hp"></a> The implementation of well-known probabilistic data structure called skip-list invented by W.Pugh in his papers:</p>
<ul>
<li>[1989] W.Pugh Skip Lists: A Probabilistic Alternative to Balanced Trees</li>
<li>[1990] W.Pugh A Skip List Cookbook</li>
</ul>
<p>A skip-list is a probabilistic data structure that provides expected logarithmic time search without the need of rebalance. The skip-list is a collection of sorted linked list. Nodes are ordered by key. Each node is linked into a subset of the lists. Each list has a level, ranging from 0 to 32. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. Each node is created with a random top level (with a random height), and belongs to all lists up to that level. The probability that a node has the height 1 is 1/2. The probability that a node has the height N is 1/2 ** N (more precisely, the distribution depends on an random generator provided, but our generators have this property).</p>
<p>The lock-free variant of skip-list is implemented according to book</p>
<ul>
<li>[2008] M.Herlihy, N.Shavit "The Art of Multiprocessor Programming", chapter 14.4 "A Lock-Free Concurrent Skiplist"</li>
</ul>
<p>Template arguments:</p>
<ul>
<li><code>GC</code> - Garbage collector used.</li>
<li><code>T</code> - type to be stored in the list.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1skip__list_1_1type__traits.html" title="Type traits for SkipListSet class.">skip_list::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based list with <a class="el" href="structcds_1_1container_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits.">cds::container::skip_list::make_traits</a> metafunction istead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <a class="el" href="structcds_1_1container_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits.">cds::container::skip_list::make_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> - key comparison functor. No default functor is provided. If the option is not specified, the <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> - specifies binary predicate used for key comparision. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a> that is no item counting.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model.">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model.">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1container_1_1skip__list_1_1random__level__generator.html" title="Typedef for intrusive::skip_list::random_level_generator template.">skip_list::random_level_generator</a> - random level generator. Can be <a class="el" href="classcds_1_1container_1_1skip__list_1_1xorshift.html" title="Typedef for intrusive::skip_list::xorshift class.">skip_list::xorshift</a>, <a class="el" href="classcds_1_1container_1_1skip__list_1_1turbo__pascal.html" title="Typedef for intrusive::skip_list::turbo_pascal class.">skip_list::turbo_pascal</a> or user-provided one. See <a class="el" href="structcds_1_1container_1_1skip__list_1_1random__level__generator.html" title="Typedef for intrusive::skip_list::random_level_generator template.">skip_list::random_level_generator</a> option description for explanation. Default is <code>skip_list::turbo_pascal</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - allocator for skip-list node. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1back__off.html" title="[type-option] Back-off strategy option setter">opt::back_off</a> - back-off strategy used. If the option is not specified, the <a class="el" href="namespacecds_1_1backoff.html#a6d7bf77f149436d5d587a2ec841e5044" title="Default backoff strategy.">cds::backoff::Default</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs">opt::stat</a> - internal statistics. Available types: <a class="el" href="classcds_1_1container_1_1skip__list_1_1stat.html" title="Typedef for intrusive::skip_list::stat class.">skip_list::stat</a>, <a class="el" href="classcds_1_1container_1_1skip__list_1_1empty__stat.html" title="Typedef for intrusive::skip_list::empty_stat class.">skip_list::empty_stat</a> (the default)</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The skip-list requires up to 67 hazard pointers that may be critical for some GCs for which the guard count is limited (like as <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a>). Those GCs should be explicitly initialized with hazard pointer enough:<div class="fragment"><div class="line">cds::gc::HP myhp( 67 ) </div>
</div><!-- fragment -->. Otherwise an run-time exception may be raised when you try to create skip-list object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are several specializations of <code>SkipListSet</code> for each <code>GC</code>. You should include:<ul>
<li><code>&lt;cds/container/skip_list_set_hp.h&gt;</code> for <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a> garbage collector</li>
<li><code>&lt;cds/container/skip_list_set_hrc.h&gt;</code> for <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a> garbage collector</li>
<li><code>&lt;cds/container/skip_list_set_ptb.h&gt;</code> for <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector.">gc::PTB</a> garbage collector</li>
<li><code>&lt;cds/container/skip_list_set_rcu.h&gt;</code> for <a class="el" href="classcds_1_1container_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListSet_rcu">RCU type</a></li>
<li><code>&lt;cds/container/skip_list_set_nogc.h&gt;</code> for <a class="el" href="classcds_1_1container_1_1_skip_list_set_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListSet_nogc">non-deletable SkipListSet</a></li>
</ul>
</dd></dl>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd">iterator</a> and <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#acd31d37191b0182f57e887790753e3bb">const_iterator</a>). The iteration is ordered. The iterator object is thread-safe: the element pointed by the iterator object is guarded, so, the element cannot be reclaimed while the iterator object is alive. However, passing an iterator object between threads is dangerous.</p>
<dl class="section warning"><dt>Warning</dt><dd>Due to concurrent nature of skip-list set it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the set, and your iteration can be terminated before end of the set. Therefore, such iteration is more suitable for debugging purpose only</dd></dl>
<p>Remember, each iterator object requires 2 additional hazard pointers, that may be a limited resource for <code>GC</code> like as <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a> and <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a> (for <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector.">gc::PTB</a> the count of guards is unlimited).</p>
<p>The iterator class supports the following minimalistic interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a>( <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a> <span class="keyword">const</span>&amp; s) ;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> * operator -&gt;() <span class="keyword">const</span> ;</div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; operator *() <span class="keyword">const</span> ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a>&amp; operator ++() ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a>&amp; src) ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_skip_list_set.html#abb219352dd6491a5efac6dd0b924a5fd" title="Iterator type.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a2a35161588bd79205c81b84919c7722c">end</a>, <code>cend</code> member functions points to <code>NULL</code> and should not be dereferenced. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9bae06c446486a883e3bf8cd9c65950d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="cds_containewr_SkipListSet_value_type"></a>Value type stored in the set </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f3b2f71972becaa6a28de52ef3956bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic). </p>
<p>The function deletes all items from the set. The function is not atomic, thus, in multi-threaded environment with parallel insertions this sequence </p>
<div class="fragment"><div class="line"><span class="keyword">set</span>.clear() ;</div>
<div class="line">assert( <span class="keyword">set</span>.<a class="code" href="classcds_1_1container_1_1_skip_list_set.html#af6994d9dcb9b7fb2b339833107efceaf" title="Checks if the set is empty.">empty</a>() ) ;</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each item the <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ab6d1447aba41ff3e49a9b7576efa7414">disposer</a> provided by <code>Traits</code> template parameter will be called. </p>

</div>
</div>
<a class="anchor" id="adb97ed3e2b3a677fb0a9abbf9025477e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_containewr_SkipListSet_value_type">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics </dd></dl>

</div>
</div>
<a class="anchor" id="a28831477fa76661cfeb2fe4884ef025c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the item exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> should be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>key</code> passed into the <code>ensure</code> function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set. </p>

</div>
</div>
<a class="anchor" id="a9c4e9e93f23fe55fc1a13c0998dc2267"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_erase_val"></a> The set item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="aa2542991a0a9f2348c9b6c5cca0ae1a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> <span class="keyword">const</span>&amp; val) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Since the key of <a class="el" href="classcds_1_1container_1_1_michael_hash_set.html" title="Michael&#39;s hash set.">MichaelHashSet</a>'s <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The list item comparator should be able to compare the type <code>T</code> of list item and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise</p>
<p>See also: <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9c4e9e93f23fe55fc1a13c0998dc2267">erase</a> </p>

</div>
</div>
<a class="anchor" id="a52388afd06ea35ed1cbd785dba52ac0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ae6bf176ad8950298a770a801f5bd68bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a9398387430b5fb2c32a984cdbbc5ba18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a53d2550d0cd568858090c90691469639"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_find_cfunc"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac835b244b8917e33d8883337fb632134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListSet_find_val"></a> The function searches the item with key equal to <code>val</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>. </p>

</div>
</div>
<a class="anchor" id="a1c073e8eff04b69d9365430a999f54a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a02d30aff076102810e08f274eb64776e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ae60b6abe7a7f5a48a583817153f5b159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#cds_nonintrusive_SkipListSet_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a58e9f24060a29d05a775108a323b804b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4f437617d9f9b09b0fc6358b3471bbe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-fields of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_skip_list_set.html#a9bae06c446486a883e3bf8cd9c65950d">value_type</a>&amp; val ) ;</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success. It may be passed by reference using <code>boost::ref</code> </p>

</div>
</div>
<a class="anchor" id="a3cfdb785d05781a79097c8d289392ae6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename T, typename Traits = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_skip_list_set.html">cds::container::SkipListSet</a>&lt; GC, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set. </p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter.">atomicity::empty_item_counter</a> this function always returns 0. Therefore, the function is not suitable for checking the set emptiness, use <a class="el" href="classcds_1_1container_1_1_skip_list_set.html#af6994d9dcb9b7fb2b339833107efceaf">empty</a> member function for this purpose. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cds/container/skip_list_base.h</li>
<li>cds/container/skip_list_set_impl.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:56 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
