<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::StripedMap&lt; Container, Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::StripedMap&lt; Container, Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Striped hash map.  
 <a href="classcds_1_1container_1_1_striped_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/striped_map.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::StripedMap&lt; Container, Options &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_striped_map.png" usemap="#cds::container::StripedMap&lt; Container, Options &gt;_map" alt=""/>
  <map id="cds::container::StripedMap&lt; Container, Options &gt;_map" name="cds::container::StripedMap&lt; Container, Options &gt;_map">
<area href="classcds_1_1container_1_1_striped_set.html" alt="cds::container::StripedSet&lt; Container, Options...&gt;" shape="rect" coords="0,56,293,80"/>
<area href="classcds_1_1intrusive_1_1_striped_set.html" alt="cds::intrusive::StripedSet&lt; Container, Options...&gt;" shape="rect" coords="0,0,293,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e8f54fde7d2f4330dbbd32e32da715a"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a2e8f54fde7d2f4330dbbd32e32da715a">underlying_container_type</a></td></tr>
<tr class="memdesc:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br/></td></tr>
<tr class="separator:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41155b6b3ff185f4ee4a64bdf256c7d"></a>
typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#af41155b6b3ff185f4ee4a64bdf256c7d">bucket_type</a></td></tr>
<tr class="memdesc:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br/></td></tr>
<tr class="separator:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc37b83c74cd041b958aba25ff3ea079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc37b83c74cd041b958aba25ff3ea079"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079">value_type</a></td></tr>
<tr class="memdesc:abc37b83c74cd041b958aba25ff3ea079"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair type (<code> std::pair&lt;key_type const, mapped_type&gt; </code>) <br/></td></tr>
<tr class="separator:abc37b83c74cd041b958aba25ff3ea079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95d2f85653d88cea2e02fc6c39a5d2b3"></a>
typedef value_type::first_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a></td></tr>
<tr class="memdesc:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br/></td></tr>
<tr class="separator:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd34343ee928de44a8d121cfdbb11b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd34343ee928de44a8d121cfdbb11b9"></a>
typedef value_type::second_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a></td></tr>
<tr class="memdesc:abcd34343ee928de44a8d121cfdbb11b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">mapped type <br/></td></tr>
<tr class="separator:abcd34343ee928de44a8d121cfdbb11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b0a9b45e942498737a5652b325e26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b1b0a9b45e942498737a5652b325e26"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a6b1b0a9b45e942498737a5652b325e26">hash</a></td></tr>
<tr class="memdesc:a6b1b0a9b45e942498737a5652b325e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br/></td></tr>
<tr class="separator:a6b1b0a9b45e942498737a5652b325e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4097c7d9306f06b3fb0ef3f351387040"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4097c7d9306f06b3fb0ef3f351387040"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a4097c7d9306f06b3fb0ef3f351387040">item_counter</a></td></tr>
<tr class="memdesc:a4097c7d9306f06b3fb0ef3f351387040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br/></td></tr>
<tr class="separator:a4097c7d9306f06b3fb0ef3f351387040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3155c54ac7cc35f2ab627ce6eb7333e3"></a>
typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a></td></tr>
<tr class="memdesc:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br/></td></tr>
<tr class="separator:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6492d65eb7a28cb6a6714b0c04b826df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6492d65eb7a28cb6a6714b0c04b826df"></a>
typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a6492d65eb7a28cb6a6714b0c04b826df">allocator_type</a></td></tr>
<tr class="memdesc:a6492d65eb7a28cb6a6714b0c04b826df"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br/></td></tr>
<tr class="separator:a6492d65eb7a28cb6a6714b0c04b826df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c68a4f3ca5a79fcffac0cb2624e0441"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0c68a4f3ca5a79fcffac0cb2624e0441">mutex_policy</a></td></tr>
<tr class="memdesc:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br/></td></tr>
<tr class="separator:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2fb520f4aeda28167438e1f7ccd531df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb520f4aeda28167438e1f7ccd531df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a2fb520f4aeda28167438e1f7ccd531df">StripedMap</a> ()</td></tr>
<tr class="memdesc:a2fb520f4aeda28167438e1f7ccd531df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br/></td></tr>
<tr class="separator:a2fb520f4aeda28167438e1f7ccd531df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892bd935c22aad68b394f3faa67ce8ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a892bd935c22aad68b394f3faa67ce8ec">StripedMap</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a892bd935c22aad68b394f3faa67ce8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="#a892bd935c22aad68b394f3faa67ce8ec">More...</a><br/></td></tr>
<tr class="separator:a892bd935c22aad68b394f3faa67ce8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ab1c828a31c862660ff8b6ae35e89e8d0">StripedMap</a> (size_t nCapacity, <a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="#ab1c828a31c862660ff8b6ae35e89e8d0">More...</a><br/></td></tr>
<tr class="separator:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad331b6324ae414f56df0324d3435a54f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ad331b6324ae414f56df0324d3435a54f">StripedMap</a> (size_t nCapacity, <a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:ad331b6324ae414f56df0324d3435a54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="#ad331b6324ae414f56df0324d3435a54f">More...</a><br/></td></tr>
<tr class="separator:ad331b6324ae414f56df0324d3435a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5a55697a29b39d471dd71b580cbc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09d5a55697a29b39d471dd71b580cbc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a09d5a55697a29b39d471dd71b580cbc3">~StripedMap</a> ()</td></tr>
<tr class="memdesc:a09d5a55697a29b39d471dd71b580cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br/></td></tr>
<tr class="separator:a09d5a55697a29b39d471dd71b580cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8306ce18508455e5a4761f8a051f6c16"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a8306ce18508455e5a4761f8a051f6c16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a8306ce18508455e5a4761f8a051f6c16">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a8306ce18508455e5a4761f8a051f6c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a8306ce18508455e5a4761f8a051f6c16">More...</a><br/></td></tr>
<tr class="separator:a8306ce18508455e5a4761f8a051f6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5543dba6bc798cb924b41de9f98cfedf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a5543dba6bc798cb924b41de9f98cfedf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a5543dba6bc798cb924b41de9f98cfedf">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a5543dba6bc798cb924b41de9f98cfedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5543dba6bc798cb924b41de9f98cfedf">More...</a><br/></td></tr>
<tr class="separator:a5543dba6bc798cb924b41de9f98cfedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae682cdec6d704833b9c863f8e0723ca2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ae682cdec6d704833b9c863f8e0723ca2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ae682cdec6d704833b9c863f8e0723ca2">insert_key</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:ae682cdec6d704833b9c863f8e0723ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#ae682cdec6d704833b9c863f8e0723ca2">More...</a><br/></td></tr>
<tr class="separator:ae682cdec6d704833b9c863f8e0723ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcdca97391447bb6f595496a227f188"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:acdcdca97391447bb6f595496a227f188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#acdcdca97391447bb6f595496a227f188">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:acdcdca97391447bb6f595496a227f188"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#acdcdca97391447bb6f595496a227f188">More...</a><br/></td></tr>
<tr class="separator:acdcdca97391447bb6f595496a227f188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a381429d609fda95120baf4393aa2f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ac5a381429d609fda95120baf4393aa2f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ac5a381429d609fda95120baf4393aa2f">ensure</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:ac5a381429d609fda95120baf4393aa2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>key</code> exists in the map.  <a href="#ac5a381429d609fda95120baf4393aa2f">More...</a><br/></td></tr>
<tr class="separator:ac5a381429d609fda95120baf4393aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abf4f29d2c1f58e1f92759f3fad808bb3">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#abf4f29d2c1f58e1f92759f3fad808bb3">More...</a><br/></td></tr>
<tr class="separator:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0f28cdf88f10e2fcc0910e00c9854f4e">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a0f28cdf88f10e2fcc0910e00c9854f4e">More...</a><br/></td></tr>
<tr class="separator:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213858e29c6865981935d07665804048"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a213858e29c6865981935d07665804048"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a213858e29c6865981935d07665804048">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a213858e29c6865981935d07665804048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a213858e29c6865981935d07665804048">More...</a><br/></td></tr>
<tr class="separator:a213858e29c6865981935d07665804048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ebc1913a673717786c8f7598b9237b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:af7ebc1913a673717786c8f7598b9237b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#af7ebc1913a673717786c8f7598b9237b">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af7ebc1913a673717786c8f7598b9237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#af7ebc1913a673717786c8f7598b9237b">More...</a><br/></td></tr>
<tr class="separator:af7ebc1913a673717786c8f7598b9237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc91ff823125ec02014aab0911083f5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a7cc91ff823125ec02014aab0911083f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a7cc91ff823125ec02014aab0911083f5">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a7cc91ff823125ec02014aab0911083f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a7cc91ff823125ec02014aab0911083f5">More...</a><br/></td></tr>
<tr class="separator:a7cc91ff823125ec02014aab0911083f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1353dfa60543a01fc0092733129a4fd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:aa1353dfa60543a01fc0092733129a4fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#aa1353dfa60543a01fc0092733129a4fd">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aa1353dfa60543a01fc0092733129a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#aa1353dfa60543a01fc0092733129a4fd">More...</a><br/></td></tr>
<tr class="separator:aa1353dfa60543a01fc0092733129a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84082e0b1dd4693e58d7ef3f477c096f"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a84082e0b1dd4693e58d7ef3f477c096f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a84082e0b1dd4693e58d7ef3f477c096f">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a84082e0b1dd4693e58d7ef3f477c096f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a84082e0b1dd4693e58d7ef3f477c096f">More...</a><br/></td></tr>
<tr class="separator:a84082e0b1dd4693e58d7ef3f477c096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d5e68c7c6a368b2626a3f5b45a1fa"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a9d4d5e68c7c6a368b2626a3f5b45a1fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a9d4d5e68c7c6a368b2626a3f5b45a1fa">find_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9d4d5e68c7c6a368b2626a3f5b45a1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a9d4d5e68c7c6a368b2626a3f5b45a1fa">More...</a><br/></td></tr>
<tr class="separator:a9d4d5e68c7c6a368b2626a3f5b45a1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13b4556ea60dfa9a77c9e44040812b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f13b4556ea60dfa9a77c9e44040812b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0f13b4556ea60dfa9a77c9e44040812b">clear</a> ()</td></tr>
<tr class="memdesc:a0f13b4556ea60dfa9a77c9e44040812b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br/></td></tr>
<tr class="separator:a0f13b4556ea60dfa9a77c9e44040812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40b5248f2986805800eef004ee9c614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ad40b5248f2986805800eef004ee9c614">empty</a> () const </td></tr>
<tr class="memdesc:ad40b5248f2986805800eef004ee9c614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#ad40b5248f2986805800eef004ee9c614">More...</a><br/></td></tr>
<tr class="separator:ad40b5248f2986805800eef004ee9c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0376d66ff292eb1352353d50e14a397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0376d66ff292eb1352353d50e14a397"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ab0376d66ff292eb1352353d50e14a397">size</a> () const </td></tr>
<tr class="memdesc:ab0376d66ff292eb1352353d50e14a397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br/></td></tr>
<tr class="separator:ab0376d66ff292eb1352353d50e14a397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c370fc1729651a2f472db97ef56a0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a96c370fc1729651a2f472db97ef56a0b">bucket_count</a> () const </td></tr>
<tr class="memdesc:a96c370fc1729651a2f472db97ef56a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a96c370fc1729651a2f472db97ef56a0b">More...</a><br/></td></tr>
<tr class="separator:a96c370fc1729651a2f472db97ef56a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1433b6b45b72fab73a4e43560f3bcb51"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a1433b6b45b72fab73a4e43560f3bcb51">lock_count</a> () const </td></tr>
<tr class="memdesc:a1433b6b45b72fab73a4e43560f3bcb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size.  <a href="#a1433b6b45b72fab73a4e43560f3bcb51">More...</a><br/></td></tr>
<tr class="separator:a1433b6b45b72fab73a4e43560f3bcb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583e325eae8997307d5c08d7d313cb46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a583e325eae8997307d5c08d7d313cb46"></a>
<a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a583e325eae8997307d5c08d7d313cb46">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a583e325eae8997307d5c08d7d313cb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br/></td></tr>
<tr class="separator:a583e325eae8997307d5c08d7d313cb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c29be20cd18584c19f9ea8679c7ac23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c29be20cd18584c19f9ea8679c7ac23"></a>
<a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a4c29be20cd18584c19f9ea8679c7ac23">get_resizing_policy</a> () const </td></tr>
<tr class="memdesc:a4c29be20cd18584c19f9ea8679c7ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br/></td></tr>
<tr class="separator:a4c29be20cd18584c19f9ea8679c7ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1container_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1container_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet&lt; Container, Options...&gt;</a></td></tr>
<tr class="memitem:ab78f765a66999a851520edd05688f688 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab78f765a66999a851520edd05688f688"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ab78f765a66999a851520edd05688f688">underlying_container_type</a></td></tr>
<tr class="memdesc:ab78f765a66999a851520edd05688f688 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br/></td></tr>
<tr class="separator:ab78f765a66999a851520edd05688f688 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd05847a606289e2125e22c390836e2d inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd05847a606289e2125e22c390836e2d"></a>
typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#acd05847a606289e2125e22c390836e2d">bucket_type</a></td></tr>
<tr class="memdesc:acd05847a606289e2125e22c390836e2d inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br/></td></tr>
<tr class="separator:acd05847a606289e2125e22c390836e2d inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497aaa946640a16825e61d14a6d6189 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2497aaa946640a16825e61d14a6d6189"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a></td></tr>
<tr class="memdesc:a2497aaa946640a16825e61d14a6d6189 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set <br/></td></tr>
<tr class="separator:a2497aaa946640a16825e61d14a6d6189 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1488d09e53e4fdadf2581db30b311 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3b1488d09e53e4fdadf2581db30b311"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ab3b1488d09e53e4fdadf2581db30b311">hash</a></td></tr>
<tr class="memdesc:ab3b1488d09e53e4fdadf2581db30b311 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br/></td></tr>
<tr class="separator:ab3b1488d09e53e4fdadf2581db30b311 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e128e84f4a17ae60a837867556050 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8e128e84f4a17ae60a837867556050"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aff8e128e84f4a17ae60a837867556050">item_counter</a></td></tr>
<tr class="memdesc:aff8e128e84f4a17ae60a837867556050 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br/></td></tr>
<tr class="separator:aff8e128e84f4a17ae60a837867556050 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132347759ae9e7929c5dc75a53890687 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a132347759ae9e7929c5dc75a53890687"></a>
typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a></td></tr>
<tr class="memdesc:a132347759ae9e7929c5dc75a53890687 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br/></td></tr>
<tr class="separator:a132347759ae9e7929c5dc75a53890687 inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae456575fca3f9634a4cbc25504d01a2a inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae456575fca3f9634a4cbc25504d01a2a"></a>
typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ae456575fca3f9634a4cbc25504d01a2a">allocator_type</a></td></tr>
<tr class="memdesc:ae456575fca3f9634a4cbc25504d01a2a inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br/></td></tr>
<tr class="separator:ae456575fca3f9634a4cbc25504d01a2a inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867de81f8ae19c2bc1d261694470ec inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52867de81f8ae19c2bc1d261694470ec"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a52867de81f8ae19c2bc1d261694470ec">mutex_policy</a></td></tr>
<tr class="memdesc:a52867de81f8ae19c2bc1d261694470ec inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br/></td></tr>
<tr class="separator:a52867de81f8ae19c2bc1d261694470ec inherit pub_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1container_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1container_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet&lt; Container, Options...&gt;</a></td></tr>
<tr class="memitem:a5b62b8c4af0730a78837e3c8a29994c2 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b62b8c4af0730a78837e3c8a29994c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a5b62b8c4af0730a78837e3c8a29994c2">StripedSet</a> ()</td></tr>
<tr class="memdesc:a5b62b8c4af0730a78837e3c8a29994c2 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br/></td></tr>
<tr class="separator:a5b62b8c4af0730a78837e3c8a29994c2 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c779ca7127d5fc03ade9a521a0338 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a319c779ca7127d5fc03ade9a521a0338">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a319c779ca7127d5fc03ade9a521a0338 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="#a319c779ca7127d5fc03ade9a521a0338">More...</a><br/></td></tr>
<tr class="separator:a319c779ca7127d5fc03ade9a521a0338 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481f34c5eb75bfb09aa7eca7f91c6e13 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a481f34c5eb75bfb09aa7eca7f91c6e13">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a481f34c5eb75bfb09aa7eca7f91c6e13 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="#a481f34c5eb75bfb09aa7eca7f91c6e13">More...</a><br/></td></tr>
<tr class="separator:a481f34c5eb75bfb09aa7eca7f91c6e13 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2289fff041c278598a6fe5e447ceb7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0a2289fff041c278598a6fe5e447ceb7">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a0a2289fff041c278598a6fe5e447ceb7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="#a0a2289fff041c278598a6fe5e447ceb7">More...</a><br/></td></tr>
<tr class="separator:a0a2289fff041c278598a6fe5e447ceb7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eee4ba35c6a33a03d12ad436cefc832 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eee4ba35c6a33a03d12ad436cefc832"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0eee4ba35c6a33a03d12ad436cefc832">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a0eee4ba35c6a33a03d12ad436cefc832 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br/></td></tr>
<tr class="separator:a0eee4ba35c6a33a03d12ad436cefc832 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8843b99b6f85ad37e9b4e4d920f523 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aff8843b99b6f85ad37e9b4e4d920f523">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:aff8843b99b6f85ad37e9b4e4d920f523 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#aff8843b99b6f85ad37e9b4e4d920f523">More...</a><br/></td></tr>
<tr class="separator:aff8843b99b6f85ad37e9b4e4d920f523 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516d09d6a558712c1827bf57bd65b53 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6516d09d6a558712c1827bf57bd65b53">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a6516d09d6a558712c1827bf57bd65b53 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a6516d09d6a558712c1827bf57bd65b53">More...</a><br/></td></tr>
<tr class="separator:a6516d09d6a558712c1827bf57bd65b53 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5007c5df1cb5cdea5f404ac25a88bd inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6a5007c5df1cb5cdea5f404ac25a88bd">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6a5007c5df1cb5cdea5f404ac25a88bd inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a6a5007c5df1cb5cdea5f404ac25a88bd">More...</a><br/></td></tr>
<tr class="separator:a6a5007c5df1cb5cdea5f404ac25a88bd inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25790de814c6ccb61797ed3b2c201ac6 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a25790de814c6ccb61797ed3b2c201ac6">ensure</a> (Q const &amp;val, Func func)</td></tr>
<tr class="memdesc:a25790de814c6ccb61797ed3b2c201ac6 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#a25790de814c6ccb61797ed3b2c201ac6">More...</a><br/></td></tr>
<tr class="separator:a25790de814c6ccb61797ed3b2c201ac6 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f2115ab187e2105c91dd933cb82d7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ad89f2115ab187e2105c91dd933cb82d7">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ad89f2115ab187e2105c91dd933cb82d7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#ad89f2115ab187e2105c91dd933cb82d7">More...</a><br/></td></tr>
<tr class="separator:ad89f2115ab187e2105c91dd933cb82d7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e75924c53c72d92082b484975af7a inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0c3e75924c53c72d92082b484975af7a">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a0c3e75924c53c72d92082b484975af7a inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a0c3e75924c53c72d92082b484975af7a">More...</a><br/></td></tr>
<tr class="separator:a0c3e75924c53c72d92082b484975af7a inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbd4712424855500108292e10935f7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a93bbd4712424855500108292e10935f7">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a93bbd4712424855500108292e10935f7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a93bbd4712424855500108292e10935f7">More...</a><br/></td></tr>
<tr class="separator:a93bbd4712424855500108292e10935f7 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af161c84a97d8357664c37720bdf77879 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#af161c84a97d8357664c37720bdf77879">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af161c84a97d8357664c37720bdf77879 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#af161c84a97d8357664c37720bdf77879">More...</a><br/></td></tr>
<tr class="separator:af161c84a97d8357664c37720bdf77879 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203525441d38698012f814d8408f6d36 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a203525441d38698012f814d8408f6d36">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a203525441d38698012f814d8408f6d36 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a203525441d38698012f814d8408f6d36">More...</a><br/></td></tr>
<tr class="separator:a203525441d38698012f814d8408f6d36 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9099506c1034b3a5f437db5e73c1d0 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#acb9099506c1034b3a5f437db5e73c1d0">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:acb9099506c1034b3a5f437db5e73c1d0 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#acb9099506c1034b3a5f437db5e73c1d0">More...</a><br/></td></tr>
<tr class="separator:acb9099506c1034b3a5f437db5e73c1d0 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc791c3ac974627ee77bf57d8458458 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aebc791c3ac974627ee77bf57d8458458">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:aebc791c3ac974627ee77bf57d8458458 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#aebc791c3ac974627ee77bf57d8458458">More...</a><br/></td></tr>
<tr class="separator:aebc791c3ac974627ee77bf57d8458458 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaecb8e05cd335c57507c1a69ea3078 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a7aaecb8e05cd335c57507c1a69ea3078">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a7aaecb8e05cd335c57507c1a69ea3078 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a7aaecb8e05cd335c57507c1a69ea3078">More...</a><br/></td></tr>
<tr class="separator:a7aaecb8e05cd335c57507c1a69ea3078 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a062a1d56946e140c120856be09b04a inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6a062a1d56946e140c120856be09b04a">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a6a062a1d56946e140c120856be09b04a inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a6a062a1d56946e140c120856be09b04a">More...</a><br/></td></tr>
<tr class="separator:a6a062a1d56946e140c120856be09b04a inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd2bd1682333ede17c7c7a3aade2a5 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aebbd2bd1682333ede17c7c7a3aade2a5">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:aebbd2bd1682333ede17c7c7a3aade2a5 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#aebbd2bd1682333ede17c7c7a3aade2a5">More...</a><br/></td></tr>
<tr class="separator:aebbd2bd1682333ede17c7c7a3aade2a5 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdfcbca5e48b3d517b9e450a06e9be1 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4bdfcbca5e48b3d517b9e450a06e9be1">clear</a> ()</td></tr>
<tr class="memdesc:a4bdfcbca5e48b3d517b9e450a06e9be1 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#a4bdfcbca5e48b3d517b9e450a06e9be1">More...</a><br/></td></tr>
<tr class="separator:a4bdfcbca5e48b3d517b9e450a06e9be1 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b79c0d6a40f53ba7db96555ab5680dc inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a1b79c0d6a40f53ba7db96555ab5680dc">empty</a> () const</td></tr>
<tr class="memdesc:a1b79c0d6a40f53ba7db96555ab5680dc inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a1b79c0d6a40f53ba7db96555ab5680dc">More...</a><br/></td></tr>
<tr class="separator:a1b79c0d6a40f53ba7db96555ab5680dc inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e178b0f136c087aeb2543162f4e134 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e178b0f136c087aeb2543162f4e134"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aa2e178b0f136c087aeb2543162f4e134">size</a> () const</td></tr>
<tr class="memdesc:aa2e178b0f136c087aeb2543162f4e134 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:aa2e178b0f136c087aeb2543162f4e134 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a8c4d24479a4a0a7f9bb843826f62 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aa84a8c4d24479a4a0a7f9bb843826f62">bucket_count</a> () const</td></tr>
<tr class="memdesc:aa84a8c4d24479a4a0a7f9bb843826f62 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#aa84a8c4d24479a4a0a7f9bb843826f62">More...</a><br/></td></tr>
<tr class="separator:aa84a8c4d24479a4a0a7f9bb843826f62 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0887399e0afc88882917adfa064a201b inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0887399e0afc88882917adfa064a201b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0887399e0afc88882917adfa064a201b">lock_count</a> () const</td></tr>
<tr class="memdesc:a0887399e0afc88882917adfa064a201b inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br/></td></tr>
<tr class="separator:a0887399e0afc88882917adfa064a201b inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cf5f431dbb6c75f92ebad633c89c3d inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28cf5f431dbb6c75f92ebad633c89c3d"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a28cf5f431dbb6c75f92ebad633c89c3d">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a28cf5f431dbb6c75f92ebad633c89c3d inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br/></td></tr>
<tr class="separator:a28cf5f431dbb6c75f92ebad633c89c3d inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496636be80484deaf1ef07fac125bf13 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a496636be80484deaf1ef07fac125bf13"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a496636be80484deaf1ef07fac125bf13">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a496636be80484deaf1ef07fac125bf13 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br/></td></tr>
<tr class="separator:a496636be80484deaf1ef07fac125bf13 inherit pub_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Container, typename... Options&gt;<br/>
class cds::container::StripedMap&lt; Container, Options &gt;</h3>

<p>Striped hash map. </p>
<p>Source</p>
<ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The map consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When the map is resized, bucket table capacity will be doubled but lock array will not. The lock <code>i</code> protects each bucket <code>j</code>, where <code> j = i mod L </code>, where <code>L</code> - the size of lock array.</p>
<p>Template arguments:</p>
<ul>
<li><code>Container</code> - the container class that is used as bucket entry. The <code>Container</code> class should support an uniform interface described below.</li>
<li><code>Options</code> - options</li>
</ul>
<p>The <code>StripedMap</code> class does not exactly specify the type of container that should be used as a <code>Container</code> bucket. Instead, the class supports different container type for the bucket, for exampe, <code>std::list</code>, <code>std::map</code> and others.</p>
<p>Remember that <code>StripedMap</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code>Options</code> template arguments.</p>
<p>The <code>Options</code> are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a> - concurrent access policy. Available policies: <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html" title="Lock striping concurrent access policy.">intrusive::striped_set::striping</a>, <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html" title="Refinable concurrent access policy.">intrusive::striped_set::refinable</a>. Default is striped_set::striping.</li>
<li><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">opt::hash</a> - hash functor. Default option value see opt::v::hash_selector&lt;opt::none&gt; which selects default hash functor for your compiler.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> - key comparison functor. No default functor is provided. If the option is not specified, the <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> - specifies binary predicate used for key comparision. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - item counter type. Default is <code><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter.">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the map algorithm, so dummy type like <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter.">atomicity::empty_item_counter</a> is not suitable.</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - the allocator type using for memory allocation of bucket table and lock array. Default is CDS_DEFAULT_ALLOCATOR.</li>
<li><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option.">opt::resizing_policy</a> - the resizing policy that is a functor that decides when to resize the hash map. Default option value depends on bucket container type: for sequential containers like <code>std::list</code>, <code>std::vector</code> the resizing policy is hash_set::load_factor_resizing&lt;4&gt;; for other type of containers like <code>std::map</code>, <code>std::unordered_map</code> the resizing policy is hash_set::no_resizing. See <a class="el" href="namespacecds_1_1intrusive_1_1striped__set.html">intrusive::striped_set</a> namespace for list of all possible types of the option. Note that the choose of resizing policy depends of <code>Container</code> type: for sequential containers like <code>std::list</code>, <code>std::vector</code> and so on, right choosing of the policy can significantly improve performance. For other, non-sequential types of <code>Container</code> (like a <code>std::map</code>) the resizing policy is not so important.</li>
<li><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option.">opt::copy_policy</a> - the copy policy which is used to copy items from the old map to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.</li>
</ul>
<p><code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a></code> or <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a></code> options are used only in some <code>Container</code> class for searching an item. <code>opt::compare</code> option has the highest priority: if <code>opt::compare</code> is specified, <code>opt::less</code> is not used.</p>
<p>You can pass other option that would be passed to <code>adapt</code> metafunction, see below.</p>
<p><b>Internal details</b></p>
<p>The <code>StripedMap</code> class cannot utilize the <code>Container</code> container specified directly, but only its adapted variant which supports an unified interface. Internally, the adaptation is made via hash_set::adapt metafunction that wraps bucket container and provides the unified bucket interface suitable for <code>StripedMap</code>. Such adaptation is completely transparent for you - you don't need to call <code>adapt</code> metafunction directly, <code>StripedMap</code> class's internal machinery itself invokes appropriate <code>adapt</code> metafunction to adjust your <code>Container</code> container class to <code>StripedMap</code> bucket's internal interface. All you need is to include a right header before <code>striped_hash_map.h</code>.</p>
<p>By default, <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html" title="Default adapter for intrusive striped/refinable hash set.">intrusive::striped_set::adapt</a>&lt;AnyContainer, Options...&gt; </code> metafunction does not make any wrapping to <code>AnyContainer</code>, so, the result <code>intrusive::striped_set::adapt&lt;AnyContainer, Options...&gt;::type </code> is the same as <code>AnyContainer</code>. However, there are a lot of specializations of <code>adapt</code> for well-known containers, see table below. Any of this specialization wraps corresponding container making it suitable for the map's bucket. Remember, you should include the proper header file for <code>adapt</code> <b>before</b> <code>striped_map.h</code>. </p>
<table class="doxtable">
<tr>
<th>Container </th><th>.h-file for <code>adapt</code>  </th><th>Example </th><th>Notes  </th></tr>
<tr>
<td><code>std::list</code>  </td><td><code>&lt;cds/container/striped_map/std_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_list.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    std::list&lt; std::pair&lt; const Key, V &gt; &gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less&lt; std::less&lt;Key&gt;</a> &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td>The type of values stored in the <code>std::list</code> must be <code> std::pair&lt; const Key, V &gt; </code>, where <code>Key</code> - key type, and <code>V</code> - value type/ The list is ordered by key <code>Key</code>. Template argument pack <code>Options</code> <b>must</b> contain <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less</a> or <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::opt::compare</a> for type <code>Key</code> stored in the list.   </td></tr>
<tr>
<td><code>std::map</code>  </td><td><code>&lt;cds/container/striped_map/std_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    std::map&lt; Key, T, std::less&lt;Key&gt; &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>std::unordered_map</code>  </td><td><code>&lt;cds/container/striped_map/std_hash_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_hash_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    std::unordered_map&lt;</div>
<div class="line">        Key, T,</div>
<div class="line">        std::hash&lt;Key&gt;,</div>
<div class="line">        std::equal_to&lt;Key&gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td>You should provide two different hash function <code>h1</code> and <code>h2</code> - one for std::unordered_map and other for <code>StripedMap</code>. For the best result, <code>h1</code> and <code>h2</code> must be orthogonal i.e. <code> h1(X) != h2(X) </code> for any value <code>X</code> of type <code>Key</code>.   </td></tr>
<tr>
<td><code>stdext::hash_map</code> (only for MS VC++ 2008) </td><td><code>&lt;cds/container/striped_map/std_hash_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_hash_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    stdext::hash_map&lt; Key, T,</div>
<div class="line">        stdext::hash_compare&lt;</div>
<div class="line">            Key,</div>
<div class="line">            std::less&lt;Key&gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td>You should provide two different hash function <code>h1</code> and <code>h2</code> - one for stdext::hash_map and other for <code>StripedMap</code>. For the best result, <code>h1</code> and <code>h2</code> must be orthogonal i.e. <code> h1(X) != h2(X) </code> for any value <code>X</code> of type <code>Key</code>.   </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td><code>&lt;cds/container/striped_map/boost_slist.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/hash_smap/boost_slist.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    boost::container::slist&lt; std::pair&lt; const Key, T &gt; &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td>The type of values stored in the <code>boost::container::slist</code> must be <code> std::pair&lt; const Key, T &gt; </code>, where <code>Key</code> - key type, and <code>T</code> - value type. The list is ordered. <code>Options</code> <b>must</b> contain <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less</a> or <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::opt::compare</a>.   </td></tr>
<tr>
<td><code>boost::container::list</code>  </td><td><code>&lt;cds/container/striped_map/boost_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_list.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    boost::container::list&lt; std::pair&lt; const Key, T &gt; &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td>The type of values stored in the <code>boost::container::list</code> must be <code> std::pair&lt; const Key, T &gt; </code>, where <code>Key</code> - key type, and <code>T</code> - value type. The list is ordered. <code>Options</code> <b>must</b> contain <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less</a> or <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::opt::compare</a>.   </td></tr>
<tr>
<td><code>boost::container::map</code>  </td><td><code>&lt;cds/container/striped_map/boost_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    boost::container::map&lt; Key, T, std::pair&lt; const Key, T&gt; &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>boost::container::flat_map</code>  </td><td><code>&lt;cds/container/striped_map/boost_flat_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_flat_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    boost::container::flat_map&lt; Key, T,</div>
<div class="line">        std::less&lt; std::pair&lt; const Key, T&gt; &gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; striped_map ;</div>
</div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>boost::unordered_map</code>  </td><td><code>&lt;cds/container/striped_map/boost_unordered_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_unordered_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/refinable_hash_map.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html" title="Striped hash map.">cds::container::StripedMap</a>&lt;</div>
<div class="line">    boost::unordered_map&lt; Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt; &gt;</div>
<div class="line">&gt; refinable_map ;</div>
</div><!-- fragment -->  </td><td></td></tr>
</table>
<p>You can use another container type as map's bucket. Suppose, you have a container class <code>MyBestContainer</code> and you want to integrate it with <code>StripedMap</code> as bucket type. There are two possibility:</p>
<ul>
<li>either your <code>MyBestContainer</code> class has native support of bucket's interface; in this case, you can use default <code>hash_set::adapt</code> metafunction;</li>
<li>or your <code>MyBestContainer</code> class does not support bucket's interface, which means, that you should develop a specialization <code>cds::container::hash_set::adapt&lt;MyBestContainer&gt; </code> metafunction providing necessary interface.</li>
</ul>
<p>The <code>hash_set::adapt&lt; Container, Options... &gt;</code> metafunction has two template argument:</p>
<ul>
<li><code>Container</code> is the class that should be used as the bucket, for example, <code>std::list&lt; std::pair&lt; Key, T &gt; &gt;</code>.</li>
<li><code>Options</code> pack is the options from <code>StripedMap</code> declaration. The <code>adapt</code> metafunction can use any option from <code>Options</code> for its internal use. For example, a <code>compare</code> option can be passed to <code>adapt</code> metafunction via <code>Options</code> argument of <code>StripedMap</code> declaration.</li>
</ul>
<p>See hash_set::adapt metafunction for the description of interface that the bucket container must provide to be <code>StripedMap</code> compatible.</p>
<p><b>Copy policy</b> There are three predefined copy policy:</p>
<ul>
<li><code>cds::container::hash_set::copy_item</code> - copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics</li>
<li><code>cds::container::hash_set::move_item</code> - move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as <code>copy_item</code> </li>
<li><code>cds::container::hash_set::swap_item</code> - copy item from old bucket to new one when resizing using <code>std::swap</code>. Not all containers support this copy policy, see details in table below.</li>
</ul>
<p>You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.</p>
<table class="doxtable">
<tr>
<th>Container </th><th>Policies  </th></tr>
<tr>
<td><ul>
<li><code>std::list</code> </li>
<li><code>boost::list</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, *itWhat ) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::pair&lt;Key, T&gt; newVal( itWhat-&gt;first, T() )    ;</div>
<div class="line">        std::swap( list.insert( itInsert, newVal )-&gt;second, itWhat-&gt;second ) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, std::move( *itWhat ) ) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
<tr>
<td><ul>
<li><code>std::map</code> </li>
<li><code>std::unordered_map</code> </li>
<li><code>stdext::hash_map</code> (only for MS VC++ 2008)</li>
<li><code>boost::container::map</code> </li>
<li><code>boost::container::flat_map</code> </li>
<li><code>boost::unordered_map</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; map, std::map&lt;Key, T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        map.insert( *itWhat ) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; map, std::map&lt;Key, T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::swap(</div>
<div class="line">            map.insert(</div>
<div class="line">                std::map::value_type( itWhat-&gt;first, T() ) ).first-&gt;second</div>
<div class="line">                , itWhat-&gt;second</div>
<div class="line">        )) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><p> <code>T</code> type must be swappable.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; map, std::map&lt;Key, T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        map.insert( std::move( *itWhat )) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->  </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::pair&lt;Key, T&gt; newVal( itWhat-&gt;first, T() )    ;</div>
<div class="line">        std::swap( list.insert( itInsert, newVal )-&gt;second, itWhat-&gt;second ) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, std::move( *itWhat ) ) ;</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
</table>
<p><b>Advanced functions</b></p>
<p><b>libcds</b> provides some advanced functions like <code>erase_with</code>, <code>find_with</code>, that cannot be supported by all underlying containers. The table below shows whether underlying container supports those functions (the sign "+" means "container supports the function"):</p>
<table class="doxtable">
<tr>
<th>Container </th><th><code>find_with</code>  </th><th><code>erse_with</code>   </th></tr>
<tr>
<td><code>std::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>std::map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>std::unordered_map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>stdext::hash_map</code> (only for MS VC++ 2008) </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::container::flat_map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::unordered_map</code>  </td><td>- </td><td>-  </td></tr>
</table>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a892bd935c22aad68b394f3faa67ce8ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1c828a31c862660ff8b6ae35e89e8d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code>resizingPolicy</code> parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad331b6324ae414f56df0324d3435a54f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code>resizingPolicy</code> parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a96c370fc1729651a2f472db97ef56a0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a class="anchor" id="acdcdca97391447bb6f595496a227f188"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>This function is available only for compiler that supports variadic template and move semantics </p>

</div>
</div>
<a class="anchor" id="ad40b5248f2986805800eef004ee9c614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a class="anchor" id="ac5a381429d609fda95120baf4393aa2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>key</code> exists in the map. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map (note that in this case the <a class="el" href="classcds_1_1container_1_1_striped_map.html#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> may be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079" title="pair type ( std::pair&lt;key_type const, mapped_type&gt; )">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079" title="pair type ( std::pair&lt;key_type const, mapped_type&gt; )">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a>.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the list. </p>

</div>
</div>
<a class="anchor" id="abf4f29d2c1f58e1f92759f3fad808bb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_erase"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a213858e29c6865981935d07665804048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079" title="pair type ( std::pair&lt;key_type const, mapped_type&gt; )">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise</p>
<p>See also: <a class="el" href="classcds_1_1container_1_1_striped_map.html#abf4f29d2c1f58e1f92759f3fad808bb3">erase</a> </p>

</div>
</div>
<a class="anchor" id="a0f28cdf88f10e2fcc0910e00c9854f4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_erase">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>erase_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="af7ebc1913a673717786c8f7598b9237b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>erase_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cc91ff823125ec02014aab0911083f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_find_func"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079" title="pair type ( std::pair&lt;key_type const, mapped_type&gt; )">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>You can pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a84082e0b1dd4693e58d7ef3f477c096f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_find_val"></a> The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aa1353dfa60543a01fc0092733129a4fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_find_func">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>find_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d4d5e68c7c6a368b2626a3f5b45a1fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_find_val">find(K const&amp;)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>find_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a8306ce18508455e5a4761f8a051f6c16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_striped_map.html#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_striped_map.html#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a5543dba6bc798cb924b41de9f98cfedf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_striped_map.html#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae682cdec6d704833b9c863f8e0723ca2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079" title="pair type ( std::pair&lt;key_type const, mapped_type&gt; )">value_type</a>&amp; item )  ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p>
<ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The user-defined functor can be passed by reference using <code>boost::ref</code> and it is called only if inserting is successful.</p>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<a class="anchor" id="a1433b6b45b72fab73a4e43560f3bcb51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size. </p>
<p>The lock array size is constant. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/striped_map.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:58 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
