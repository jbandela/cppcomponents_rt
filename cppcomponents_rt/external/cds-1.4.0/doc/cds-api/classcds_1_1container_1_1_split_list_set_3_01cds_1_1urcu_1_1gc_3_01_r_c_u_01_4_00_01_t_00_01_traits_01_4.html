<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html">SplitListSet< cds::urcu::gc< RCU >, T, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Maps and Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Split-ordered list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/split_list_set_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.png" usemap="#cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map" name="cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_split_list_set.html" alt="cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, Traits::ordered_list, Traits &gt;" shape="rect" coords="0,0,451,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a44a529840eda78e5a670b1fec9783858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a529840eda78e5a670b1fec9783858"></a>
typedef options::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a44a529840eda78e5a670b1fec9783858">gc</a></td></tr>
<tr class="memdesc:a44a529840eda78e5a670b1fec9783858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:a44a529840eda78e5a670b1fec9783858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa0c64fca19276721158ffe389d631"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13aa0c64fca19276721158ffe389d631"></a>
typedef options::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a></td></tr>
<tr class="memdesc:a13aa0c64fca19276721158ffe389d631"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the list <br/></td></tr>
<tr class="separator:a13aa0c64fca19276721158ffe389d631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe2df362778bb46118811ea90210ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ffe2df362778bb46118811ea90210ff"></a>
typedef options::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3ffe2df362778bb46118811ea90210ff">ordered_list</a></td></tr>
<tr class="memdesc:a3ffe2df362778bb46118811ea90210ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br/></td></tr>
<tr class="separator:a3ffe2df362778bb46118811ea90210ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81db4384b05b8e025bb11a2b9885e1df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81db4384b05b8e025bb11a2b9885e1df"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a81db4384b05b8e025bb11a2b9885e1df">key_comparator</a></td></tr>
<tr class="memdesc:a81db4384b05b8e025bb11a2b9885e1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br/></td></tr>
<tr class="separator:a81db4384b05b8e025bb11a2b9885e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82af9b8890322b2afc85194c14d8ba74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82af9b8890322b2afc85194c14d8ba74"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a82af9b8890322b2afc85194c14d8ba74">hash</a></td></tr>
<tr class="memdesc:a82af9b8890322b2afc85194c14d8ba74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a> and all its derivatives that you use. <br/></td></tr>
<tr class="separator:a82af9b8890322b2afc85194c14d8ba74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535b717d0a578311b8afb5f3e6f1d7f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535b717d0a578311b8afb5f3e6f1d7f0"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a535b717d0a578311b8afb5f3e6f1d7f0">item_counter</a></td></tr>
<tr class="memdesc:a535b717d0a578311b8afb5f3e6f1d7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br/></td></tr>
<tr class="separator:a535b717d0a578311b8afb5f3e6f1d7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c87cc75df17ac89786d9b7fc6c432"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f2c87cc75df17ac89786d9b7fc6c432"></a>
typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a></td></tr>
<tr class="memdesc:a5f2c87cc75df17ac89786d9b7fc6c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br/></td></tr>
<tr class="separator:a5f2c87cc75df17ac89786d9b7fc6c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9af7fdce306b796a7e3cd49cdea120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f9af7fdce306b796a7e3cd49cdea120"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a></td></tr>
<tr class="memdesc:a9f9af7fdce306b796a7e3cd49cdea120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br/></td></tr>
<tr class="separator:a9f9af7fdce306b796a7e3cd49cdea120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa10261c1a5f803f9542dee47988ca16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaa10261c1a5f803f9542dee47988ca16">SplitListSet</a> ()</td></tr>
<tr class="memdesc:aaa10261c1a5f803f9542dee47988ca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list of default capacity.  <a href="#aaa10261c1a5f803f9542dee47988ca16">More...</a><br/></td></tr>
<tr class="separator:aaa10261c1a5f803f9542dee47988ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae45b7ca0c41055ef152d51c0de0519"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2ae45b7ca0c41055ef152d51c0de0519">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a2ae45b7ca0c41055ef152d51c0de0519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list.  <a href="#a2ae45b7ca0c41055ef152d51c0de0519">More...</a><br/></td></tr>
<tr class="separator:a2ae45b7ca0c41055ef152d51c0de0519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b749193c0afb53019a23e55d056e30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5b749193c0afb53019a23e55d056e30d">begin</a> ()</td></tr>
<tr class="memdesc:a5b749193c0afb53019a23e55d056e30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set.  <a href="#a5b749193c0afb53019a23e55d056e30d">More...</a><br/></td></tr>
<tr class="separator:a5b749193c0afb53019a23e55d056e30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730086ffb1a533f013ca86bd43d1d719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719">end</a> ()</td></tr>
<tr class="memdesc:a730086ffb1a533f013ca86bd43d1d719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a set.  <a href="#a730086ffb1a533f013ca86bd43d1d719">More...</a><br/></td></tr>
<tr class="separator:a730086ffb1a533f013ca86bd43d1d719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e608729f80c976b658171516b0395f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18e608729f80c976b658171516b0395f"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a18e608729f80c976b658171516b0395f">begin</a> () const </td></tr>
<tr class="memdesc:a18e608729f80c976b658171516b0395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a18e608729f80c976b658171516b0395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64a649a14c127c82e6f773d8c30b7ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad64a649a14c127c82e6f773d8c30b7ff"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad64a649a14c127c82e6f773d8c30b7ff">end</a> () const </td></tr>
<tr class="memdesc:ad64a649a14c127c82e6f773d8c30b7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:ad64a649a14c127c82e6f773d8c30b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5426434330a53312429d8d721fb66cc7"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5426434330a53312429d8d721fb66cc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5426434330a53312429d8d721fb66cc7">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a5426434330a53312429d8d721fb66cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5426434330a53312429d8d721fb66cc7">More...</a><br/></td></tr>
<tr class="separator:a5426434330a53312429d8d721fb66cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6a97dd49c0995a3f761e57ab0533db"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a4f6a97dd49c0995a3f761e57ab0533db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a4f6a97dd49c0995a3f761e57ab0533db">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a4f6a97dd49c0995a3f761e57ab0533db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4f6a97dd49c0995a3f761e57ab0533db">More...</a><br/></td></tr>
<tr class="separator:a4f6a97dd49c0995a3f761e57ab0533db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28502e723c54f48822af1c0ac9abb3f9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a28502e723c54f48822af1c0ac9abb3f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a28502e723c54f48822af1c0ac9abb3f9">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a28502e723c54f48822af1c0ac9abb3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a28502e723c54f48822af1c0ac9abb3f9">More...</a><br/></td></tr>
<tr class="separator:a28502e723c54f48822af1c0ac9abb3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeb455a97f72ee67e00309f285e7eae"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:afeeb455a97f72ee67e00309f285e7eae"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#afeeb455a97f72ee67e00309f285e7eae">ensure</a> (Q const &amp;val, Func func)</td></tr>
<tr class="memdesc:afeeb455a97f72ee67e00309f285e7eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>item</code> exists in the set.  <a href="#afeeb455a97f72ee67e00309f285e7eae">More...</a><br/></td></tr>
<tr class="separator:afeeb455a97f72ee67e00309f285e7eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9d2591d87d680e1e0942e28a636e8"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac2d9d2591d87d680e1e0942e28a636e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac2d9d2591d87d680e1e0942e28a636e8">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ac2d9d2591d87d680e1e0942e28a636e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#ac2d9d2591d87d680e1e0942e28a636e8">More...</a><br/></td></tr>
<tr class="separator:ac2d9d2591d87d680e1e0942e28a636e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0813e79767faec8708232805e1e63e8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ac0813e79767faec8708232805e1e63e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac0813e79767faec8708232805e1e63e8">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ac0813e79767faec8708232805e1e63e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ac0813e79767faec8708232805e1e63e8">More...</a><br/></td></tr>
<tr class="separator:ac0813e79767faec8708232805e1e63e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a0a2ad7d9963027c9f44c7a9e4bd7a2ae">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#a0a2ad7d9963027c9f44c7a9e4bd7a2ae">More...</a><br/></td></tr>
<tr class="separator:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e77899f2784acde39124d511b47c53"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ad8e77899f2784acde39124d511b47c53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad8e77899f2784acde39124d511b47c53">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ad8e77899f2784acde39124d511b47c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ad8e77899f2784acde39124d511b47c53">More...</a><br/></td></tr>
<tr class="separator:ad8e77899f2784acde39124d511b47c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc445527780ac40a2e8ad5dc480360f6"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:acc445527780ac40a2e8ad5dc480360f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#acc445527780ac40a2e8ad5dc480360f6">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:acc445527780ac40a2e8ad5dc480360f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#acc445527780ac40a2e8ad5dc480360f6">More...</a><br/></td></tr>
<tr class="separator:acc445527780ac40a2e8ad5dc480360f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027de11aa3784ac1d1fb52e1a3a88df4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a027de11aa3784ac1d1fb52e1a3a88df4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a027de11aa3784ac1d1fb52e1a3a88df4">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a027de11aa3784ac1d1fb52e1a3a88df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a027de11aa3784ac1d1fb52e1a3a88df4">More...</a><br/></td></tr>
<tr class="separator:a027de11aa3784ac1d1fb52e1a3a88df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae346c1fd0810284b48045f910ec2c7b8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae346c1fd0810284b48045f910ec2c7b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae346c1fd0810284b48045f910ec2c7b8">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ae346c1fd0810284b48045f910ec2c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#ae346c1fd0810284b48045f910ec2c7b8">More...</a><br/></td></tr>
<tr class="separator:ae346c1fd0810284b48045f910ec2c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab3bbff0e1926afa920082c63819755"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a3ab3bbff0e1926afa920082c63819755"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3ab3bbff0e1926afa920082c63819755">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a3ab3bbff0e1926afa920082c63819755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a3ab3bbff0e1926afa920082c63819755">More...</a><br/></td></tr>
<tr class="separator:a3ab3bbff0e1926afa920082c63819755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9626b75ca1bc8166ecb059a53fa8b4db"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9626b75ca1bc8166ecb059a53fa8b4db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9626b75ca1bc8166ecb059a53fa8b4db">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a9626b75ca1bc8166ecb059a53fa8b4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a9626b75ca1bc8166ecb059a53fa8b4db">More...</a><br/></td></tr>
<tr class="separator:a9626b75ca1bc8166ecb059a53fa8b4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20895471bfcf2c99a076acab26bfd5"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a3a20895471bfcf2c99a076acab26bfd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3a20895471bfcf2c99a076acab26bfd5">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a3a20895471bfcf2c99a076acab26bfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a3a20895471bfcf2c99a076acab26bfd5">More...</a><br/></td></tr>
<tr class="separator:a3a20895471bfcf2c99a076acab26bfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158e36626a98950dfa704e56350f8c7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a158e36626a98950dfa704e56350f8c7a">clear</a> ()</td></tr>
<tr class="memdesc:a158e36626a98950dfa704e56350f8c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a158e36626a98950dfa704e56350f8c7a">More...</a><br/></td></tr>
<tr class="separator:a158e36626a98950dfa704e56350f8c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f570701db4f0827322fb22444ca81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a235f570701db4f0827322fb22444ca81">empty</a> () const </td></tr>
<tr class="memdesc:a235f570701db4f0827322fb22444ca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a235f570701db4f0827322fb22444ca81">More...</a><br/></td></tr>
<tr class="separator:a235f570701db4f0827322fb22444ca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f079e7d7798a64e9be27148fba7a4d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f079e7d7798a64e9be27148fba7a4d5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7f079e7d7798a64e9be27148fba7a4d5">size</a> () const </td></tr>
<tr class="memdesc:a7f079e7d7798a64e9be27148fba7a4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:a7f079e7d7798a64e9be27148fba7a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, Traits::ordered_list, Traits &gt;</a></td></tr>
<tr class="memitem:a824c57fabb2f0d47af56b5fd58002433 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a824c57fabb2f0d47af56b5fd58002433"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a824c57fabb2f0d47af56b5fd58002433">options</a></td></tr>
<tr class="memdesc:a824c57fabb2f0d47af56b5fd58002433 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameters. <br/></td></tr>
<tr class="separator:a824c57fabb2f0d47af56b5fd58002433 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2de69bd86f37bd184ca50d50e29f0e inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea2de69bd86f37bd184ca50d50e29f0e"></a>
typedef <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aea2de69bd86f37bd184ca50d50e29f0e">gc</a></td></tr>
<tr class="memdesc:aea2de69bd86f37bd184ca50d50e29f0e inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:aea2de69bd86f37bd184ca50d50e29f0e inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719263aaf48921d5ced55707389f961a inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a719263aaf48921d5ced55707389f961a"></a>
typedef Traits::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a></td></tr>
<tr class="memdesc:a719263aaf48921d5ced55707389f961a inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list used as base for split-list <br/></td></tr>
<tr class="separator:a719263aaf48921d5ced55707389f961a inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae9f358f06403565d75e8a6666e0f8f inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afae9f358f06403565d75e8a6666e0f8f"></a>
typedef ordered_list::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a></td></tr>
<tr class="memdesc:afae9f358f06403565d75e8a6666e0f8f inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the split-list <br/></td></tr>
<tr class="separator:afae9f358f06403565d75e8a6666e0f8f inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac7447e2749a53db596bef99378f0a inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4ac7447e2749a53db596bef99378f0a"></a>
typedef <br class="typebreak"/>
ordered_list::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac4ac7447e2749a53db596bef99378f0a">key_comparator</a></td></tr>
<tr class="memdesc:ac4ac7447e2749a53db596bef99378f0a inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparision functor <br/></td></tr>
<tr class="separator:ac4ac7447e2749a53db596bef99378f0a inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cfc2f23920086d62cef263e4b4f879 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4cfc2f23920086d62cef263e4b4f879"></a>
typedef ordered_list::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa4cfc2f23920086d62cef263e4b4f879">disposer</a></td></tr>
<tr class="memdesc:aa4cfc2f23920086d62cef263e4b4f879 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node disposer functor. <br/></td></tr>
<tr class="separator:aa4cfc2f23920086d62cef263e4b4f879 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fbc82374ae1eb1a194facd1821f78d inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92fbc82374ae1eb1a194facd1821f78d"></a>
typedef <br class="typebreak"/>
cds::opt::v::hash_selector<br class="typebreak"/>
&lt; typename options::hash &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a92fbc82374ae1eb1a194facd1821f78d">hash</a></td></tr>
<tr class="memdesc:a92fbc82374ae1eb1a194facd1821f78d inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives that you use. <br/></td></tr>
<tr class="separator:a92fbc82374ae1eb1a194facd1821f78d inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae718c3d6348e131621da0d4e3db7437 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae718c3d6348e131621da0d4e3db7437"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aae718c3d6348e131621da0d4e3db7437">item_counter</a></td></tr>
<tr class="memdesc:aae718c3d6348e131621da0d4e3db7437 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br/></td></tr>
<tr class="separator:aae718c3d6348e131621da0d4e3db7437 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc7678a1374b22a4cc53de858ab83b4 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fc7678a1374b22a4cc53de858ab83b4"></a>
typedef options::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a5fc7678a1374b22a4cc53de858ab83b4">back_off</a></td></tr>
<tr class="memdesc:a5fc7678a1374b22a4cc53de858ab83b4 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy for spinning <br/></td></tr>
<tr class="separator:a5fc7678a1374b22a4cc53de858ab83b4 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac91f5eb5e94fa5e4a5e7ff4abc1da5 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac91f5eb5e94fa5e4a5e7ff4abc1da5"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4ac91f5eb5e94fa5e4a5e7ff4abc1da5">memory_model</a></td></tr>
<tr class="memdesc:a4ac91f5eb5e94fa5e4a5e7ff4abc1da5 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a4ac91f5eb5e94fa5e4a5e7ff4abc1da5 inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a></td></tr>
<tr class="memdesc:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#a2c70b5bacc4b3d7d69efbf122f4d2c0b">More...</a><br/></td></tr>
<tr class="separator:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6498e34acc524dd27767347acefbdb inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a></td></tr>
<tr class="memdesc:a1e6498e34acc524dd27767347acefbdb inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="#a1e6498e34acc524dd27767347acefbdb">More...</a><br/></td></tr>
<tr class="separator:a1e6498e34acc524dd27767347acefbdb inherit pub_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201b859e6aed58eec5f6fd6a0675e5b2 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a201b859e6aed58eec5f6fd6a0675e5b2"></a>
typedef ordered_list::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a201b859e6aed58eec5f6fd6a0675e5b2">list_node_type</a></td></tr>
<tr class="memdesc:a201b859e6aed58eec5f6fd6a0675e5b2 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type as declared in ordered list. <br/></td></tr>
<tr class="separator:a201b859e6aed58eec5f6fd6a0675e5b2 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee655bc764efdc41d05fe77e4b19b1f9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee655bc764efdc41d05fe77e4b19b1f9"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node.html">split_list::node</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a201b859e6aed58eec5f6fd6a0675e5b2">list_node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aee655bc764efdc41d05fe77e4b19b1f9">node_type</a></td></tr>
<tr class="memdesc:aee655bc764efdc41d05fe77e4b19b1f9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">split-list node type <br/></td></tr>
<tr class="separator:aee655bc764efdc41d05fe77e4b19b1f9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020349ff19b12af6d9486cf56aadf083 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a020349ff19b12af6d9486cf56aadf083"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aee655bc764efdc41d05fe77e4b19b1f9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a020349ff19b12af6d9486cf56aadf083">dummy_node_type</a></td></tr>
<tr class="memdesc:a020349ff19b12af6d9486cf56aadf083 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy node type <br/></td></tr>
<tr class="separator:a020349ff19b12af6d9486cf56aadf083 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf536340156f632edfd5bd4f8947e71 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node__traits.html">split_list::node_traits</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
ordered_list::node_traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aeaf536340156f632edfd5bd4f8947e71">node_traits</a></td></tr>
<tr class="memdesc:aeaf536340156f632edfd5bd4f8947e71 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-list node traits.  <a href="#aeaf536340156f632edfd5bd4f8947e71">More...</a><br/></td></tr>
<tr class="separator:aeaf536340156f632edfd5bd4f8947e71 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, Traits::ordered_list, Traits &gt;</a></td></tr>
<tr class="memitem:a685c56051b1ffc44511a5ec12b80b2d0 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a685c56051b1ffc44511a5ec12b80b2d0">SplitListSet</a> ()</td></tr>
<tr class="memdesc:a685c56051b1ffc44511a5ec12b80b2d0 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list of default capacity.  <a href="#a685c56051b1ffc44511a5ec12b80b2d0">More...</a><br/></td></tr>
<tr class="separator:a685c56051b1ffc44511a5ec12b80b2d0 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c73356d78265849a8cce93155480eb inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a56c73356d78265849a8cce93155480eb">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a56c73356d78265849a8cce93155480eb inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list.  <a href="#a56c73356d78265849a8cce93155480eb">More...</a><br/></td></tr>
<tr class="separator:a56c73356d78265849a8cce93155480eb inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a5fa996ee4f495c0a059c3bb031f7aa06">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5fa996ee4f495c0a059c3bb031f7aa06">More...</a><br/></td></tr>
<tr class="separator:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fc790b0a2969b2795ddad438d4243a inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a93fc790b0a2969b2795ddad438d4243a">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a93fc790b0a2969b2795ddad438d4243a inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a93fc790b0a2969b2795ddad438d4243a">More...</a><br/></td></tr>
<tr class="separator:a93fc790b0a2969b2795ddad438d4243a inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26023d508564add45da6aa92d947c78 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#af26023d508564add45da6aa92d947c78">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:af26023d508564add45da6aa92d947c78 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#af26023d508564add45da6aa92d947c78">More...</a><br/></td></tr>
<tr class="separator:af26023d508564add45da6aa92d947c78 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">More...</a><br/></td></tr>
<tr class="separator:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610ff8dbb656077180463a7c9951426c inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a610ff8dbb656077180463a7c9951426c">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a610ff8dbb656077180463a7c9951426c inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a610ff8dbb656077180463a7c9951426c">More...</a><br/></td></tr>
<tr class="separator:a610ff8dbb656077180463a7c9951426c inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f17114e5dc35b6e2d5c0d6973b4d5b inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a79f17114e5dc35b6e2d5c0d6973b4d5b">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a79f17114e5dc35b6e2d5c0d6973b4d5b inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a79f17114e5dc35b6e2d5c0d6973b4d5b">More...</a><br/></td></tr>
<tr class="separator:a79f17114e5dc35b6e2d5c0d6973b4d5b inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73630ad86bfdf1b23008696d2acf91cd inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a73630ad86bfdf1b23008696d2acf91cd">erase_with</a> (const Q &amp;val, Less pred)</td></tr>
<tr class="memdesc:a73630ad86bfdf1b23008696d2acf91cd inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#a73630ad86bfdf1b23008696d2acf91cd">More...</a><br/></td></tr>
<tr class="separator:a73630ad86bfdf1b23008696d2acf91cd inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c57fbf3db246fdd13bba2597a25b9 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a877c57fbf3db246fdd13bba2597a25b9">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a877c57fbf3db246fdd13bba2597a25b9 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#a877c57fbf3db246fdd13bba2597a25b9">More...</a><br/></td></tr>
<tr class="separator:a877c57fbf3db246fdd13bba2597a25b9 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470efcf0f0f4a0934ce54bbac69d0185 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a470efcf0f0f4a0934ce54bbac69d0185">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a470efcf0f0f4a0934ce54bbac69d0185 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a470efcf0f0f4a0934ce54bbac69d0185">More...</a><br/></td></tr>
<tr class="separator:a470efcf0f0f4a0934ce54bbac69d0185 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e665a8ae26cb95b9bb824e79bde47a6 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2e665a8ae26cb95b9bb824e79bde47a6">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a2e665a8ae26cb95b9bb824e79bde47a6 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a2e665a8ae26cb95b9bb824e79bde47a6">More...</a><br/></td></tr>
<tr class="separator:a2e665a8ae26cb95b9bb824e79bde47a6 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81299fe8d000acdad2c06ae1e5f92797 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a81299fe8d000acdad2c06ae1e5f92797">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a81299fe8d000acdad2c06ae1e5f92797 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a81299fe8d000acdad2c06ae1e5f92797">More...</a><br/></td></tr>
<tr class="separator:a81299fe8d000acdad2c06ae1e5f92797 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70657b60341d29b64926fc02a191eb7c inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a70657b60341d29b64926fc02a191eb7c">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a70657b60341d29b64926fc02a191eb7c inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with <code>pred</code> predicate for comparing.  <a href="#a70657b60341d29b64926fc02a191eb7c">More...</a><br/></td></tr>
<tr class="separator:a70657b60341d29b64926fc02a191eb7c inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c532849d3f414ae9a3d4b6b97eb6ce inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac2c532849d3f414ae9a3d4b6b97eb6ce">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ac2c532849d3f414ae9a3d4b6b97eb6ce inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with <code>pred</code> predicate for comparing.  <a href="#ac2c532849d3f414ae9a3d4b6b97eb6ce">More...</a><br/></td></tr>
<tr class="separator:ac2c532849d3f414ae9a3d4b6b97eb6ce inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac57ea8da5596d39a930c886377a26 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a50ac57ea8da5596d39a930c886377a26">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a50ac57ea8da5596d39a930c886377a26 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with <code>pred</code> predicate for comparing.  <a href="#a50ac57ea8da5596d39a930c886377a26">More...</a><br/></td></tr>
<tr class="separator:a50ac57ea8da5596d39a930c886377a26 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa1bf063e7d77c1bf66af27c9ace40a inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa1bf063e7d77c1bf66af27c9ace40a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a7aa1bf063e7d77c1bf66af27c9ace40a">size</a> () const</td></tr>
<tr class="memdesc:a7aa1bf063e7d77c1bf66af27c9ace40a inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br/></td></tr>
<tr class="separator:a7aa1bf063e7d77c1bf66af27c9ace40a inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d58c4927bf06251506a711cc04e1b25 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2d58c4927bf06251506a711cc04e1b25">empty</a> () const</td></tr>
<tr class="memdesc:a2d58c4927bf06251506a711cc04e1b25 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a2d58c4927bf06251506a711cc04e1b25">More...</a><br/></td></tr>
<tr class="separator:a2d58c4927bf06251506a711cc04e1b25 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fc77a7939fd3553a594fc5a315572 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0f3fc77a7939fd3553a594fc5a315572">clear</a> ()</td></tr>
<tr class="memdesc:a0f3fc77a7939fd3553a594fc5a315572 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a0f3fc77a7939fd3553a594fc5a315572">More...</a><br/></td></tr>
<tr class="separator:a0f3fc77a7939fd3553a594fc5a315572 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f775376add33a1d7d2b82463670a55 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae9f775376add33a1d7d2b82463670a55">begin</a> ()</td></tr>
<tr class="memdesc:ae9f775376add33a1d7d2b82463670a55 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a split-list.  <a href="#ae9f775376add33a1d7d2b82463670a55">More...</a><br/></td></tr>
<tr class="separator:ae9f775376add33a1d7d2b82463670a55 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1674dacb1ce36c99bfcfc714fe721 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2d1674dacb1ce36c99bfcfc714fe721"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa2d1674dacb1ce36c99bfcfc714fe721">begin</a> () const</td></tr>
<tr class="memdesc:aa2d1674dacb1ce36c99bfcfc714fe721 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br/></td></tr>
<tr class="separator:aa2d1674dacb1ce36c99bfcfc714fe721 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4f5c1a7fb52b15cea10bbaa04c926517">end</a> ()</td></tr>
<tr class="memdesc:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a split-list.  <a href="#a4f5c1a7fb52b15cea10bbaa04c926517">More...</a><br/></td></tr>
<tr class="separator:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e4856422504f1a0c4350ed10c40532 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e4856422504f1a0c4350ed10c40532"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab9e4856422504f1a0c4350ed10c40532">end</a> () const</td></tr>
<tr class="memdesc:ab9e4856422504f1a0c4350ed10c40532 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br/></td></tr>
<tr class="separator:ab9e4856422504f1a0c4350ed10c40532 inherit pub_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, class T, class Traits = split_list::type_traits&gt;<br/>
class cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</h3>

<p>Split-ordered list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu"></a> Hash table implementation based on split-ordered list algorithm discovered by Ori Shalev and Nir Shavit, see</p>
<ul>
<li>[2003] Ori Shalev, Nir Shavit "Split-Ordered Lists - Lock-free Resizable Hash Tables"</li>
<li>[2008] Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>See <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html" title="Split-ordered list.">intrusive::SplitListSet</a> for a brief description of the split-list algorithm.</p>
<p>Template parameters:</p>
<ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>T</code> - type stored in the split-list. The type must be default- and copy-constructible.</li>
<li><code>Traits</code> - type traits, default is <a class="el" href="structcds_1_1container_1_1split__list_1_1type__traits.html" title="Type traits for SplitListSet class.">split_list::type_traits</a>. Instead of declaring <a class="el" href="structcds_1_1container_1_1split__list_1_1type__traits.html" title="Type traits for SplitListSet class.">split_list::type_traits</a> -based struct you may apply option-based notation with <a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct.">split_list::make_traits</a> metafunction.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> and <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>). The iteration is ordered.</p>
<p>You may iterate over split-list set items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any set's item cannot be reclaimed.</p>
<p>The requirement of RCU lock during iterating means that deletion of the elements (i.e. <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac2d9d2591d87d680e1e0942e28a636e8">erase</a>) is not possible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads</dd>
<dd>
Due to concurrent nature of skip-list set it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the set, and your iteration can be terminated before end of the set. Therefore, such iteration is more suitable for debugging purposes</dd></dl>
<p>The iterator class supports the following minimalistic interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a>( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; s) ;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a> * operator -&gt;() <span class="keyword">const</span> ;</div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a>&amp; operator *() <span class="keyword">const</span> ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a>&amp; operator ++() ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a>&amp; src) ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432" title="Forward iterator.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719">end</a>, <code>cend</code> member functions points to <code>NULL</code> and should not be dereferenced.</p>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
<p>You should decide what garbage collector you want, and what ordered list you want to use. Split-ordered list is an original data structure based on an ordered list. Suppose, you want construct split-list set based on cds::urcu::general_buffered&lt;&gt; GC and <a class="el" href="classcds_1_1container_1_1_lazy_list.html" title="Lazy ordered list.">LazyList</a> as ordered list implementation. So, you beginning your program with following include: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/lazy_list_rcu.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/split_list_set_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>cc = cds::container ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The data belonged to split-ordered list</span></div>
<div class="line">sturuct foo {</div>
<div class="line">    <span class="keywordtype">int</span>     nKey;   <span class="comment">// key field</span></div>
<div class="line">    std::string strValue    ;   <span class="comment">// value field</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> The inclusion order is important:</p>
<ul>
<li>first, include one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU implementation</a> (<code>cds/urcu/general_buffered.h</code> in our case)</li>
<li>second, include file for ordered-list implementation (for this example, <code>cds/container/lazy_list_rcu.h</code>),</li>
<li>then, the header for RCU-based split-list set <code>cds/container/split_list_set_rcu.h</code>.</li>
</ul>
<p>Now, you should declare traits for split-list set. The main parts of traits are a hash functor for the set and a comparing functor for ordered list. Note that we define several function in <code>foo_hash</code> and <code>foo_less</code> functors for different argument types since we want call our <code>SplitListSet</code> object by the key of type <code>int</code> and by the value of type <code>foo</code>.</p>
<p>The second attention: instead of using <a class="el" href="classcds_1_1container_1_1_lazy_list.html" title="Lazy ordered list.">LazyList</a> in <a class="el" href="classcds_1_1container_1_1_split_list_set.html" title="Split-ordered list set.">SplitListSet</a> traits we use a tag <code>cds::contaner::lazy_list_tag</code> for the lazy list. The split-list requires significant support from underlying ordered list class and it is not good idea to dive you into deep implementation details of split-list and ordered list interrelations. The tag paradigm simplifies split-list interface.</p>
<div class="fragment"><div class="line"><span class="comment">// foo hash functor</span></div>
<div class="line"><span class="keyword">struct </span>foo_hash {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()( <span class="keywordtype">int</span> key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::hash( key ) ; }</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()( foo <span class="keyword">const</span>&amp; item )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::hash( item.nKey ) ; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// foo comparator</span></div>
<div class="line"><span class="keyword">struct </span>foo_less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> i, foo <span class="keyword">const</span>&amp; f )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> i &lt; f.nKey ; }</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(foo <span class="keyword">const</span>&amp; f, <span class="keywordtype">int</span> i )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f.nKey &lt; i ; }</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(foo <span class="keyword">const</span>&amp; f1, foo <span class="keyword">const</span>&amp; f2)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f1.nKey &lt; f2.nKey; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// SplitListSet traits</span></div>
<div class="line"><span class="keyword">struct </span>foo_set_traits: <span class="keyword">public</span> cc::split_list::type_traits</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> cc::lazy_list_tag   <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a3ffe2df362778bb46118811ea90210ff" title="Underlying ordered list class.">ordered_list</a>    ;   <span class="comment">// what type of ordered list we want to use</span></div>
<div class="line">    <span class="keyword">typedef</span> foo_hash            <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a82af9b8890322b2afc85194c14d8ba74" title="Hash functor for value_type and all its derivatives that you use.">hash</a>            ;   <span class="comment">// hash functor for our data stored in split-list set</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Type traits for our LazyList class</span></div>
<div class="line">    <span class="keyword">struct </span>ordered_list_traits: <span class="keyword">public</span> cc::lazy_list::type_traits</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typedef</span> foo_less less   ;   <span class="comment">// use our foo_less as comparator to order list nodes</span></div>
<div class="line">    } ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now you are ready to declare our set class based on <code>SplitListSet</code>: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cc::SplitListSet&lt; cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;, foo, foo_set_traits &gt; foo_set   ;</div>
</div><!-- fragment --><p>You may use the modern option-based declaration instead of classic type-traits-based one: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cc:<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaa10261c1a5f803f9542dee47988ca16" title="Initializes split-ordered list of default capacity.">SplitListSet</a>&lt;</div>
<div class="line">    cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;   <span class="comment">// RCU type used</span></div>
<div class="line">    ,foo                                            <span class="comment">// type of data stored</span></div>
<div class="line">    ,cc::split_list::make_traits&lt;      <span class="comment">// metafunction to build split-list traits</span></div>
<div class="line">        cc::split_list::ordered_list&lt;cc::lazy_list_tag&gt;     <span class="comment">// tag for underlying ordered list implementation</span></div>
<div class="line">        ,cc::opt::hash&lt; foo_hash &gt;              <span class="comment">// hash functor</span></div>
<div class="line">        ,cc::split_list::ordered_list_traits&lt;   <span class="comment">// ordered list traits desired</span></div>
<div class="line">            cc::lazy_list::make_traits&lt;         <span class="comment">// metafunction to build lazy list traits</span></div>
<div class="line">                cc::opt::less&lt; foo_less &gt;           <span class="comment">// less-based compare functor</span></div>
<div class="line">            &gt;::type</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt;  foo_set ;</div>
</div><!-- fragment --><p> In case of option-based declaration using <a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct.">split_list::make_traits</a> metafunction the struct <code>foo_set_traits</code> is not required.</p>
<p>Now, the set of type <code>foo_set</code> is ready to use in your program.</p>
<p>Note that in this example we show only mandatory type_traits parts, optional ones is the default and they are inherited from <a class="el" href="structcds_1_1container_1_1split__list_1_1type__traits.html" title="Type traits for SplitListSet class.">cds::container::split_list::type_traits</a>. The <b>cds</b> library contains many other options for deep tuning of behavior of the split-list and ordered-list containers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaa10261c1a5f803f9542dee47988ca16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set.html">SplitListSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered list of default capacity. </p>
<p>The default capacity is defined in bucket table constructor. See <a class="el" href="classcds_1_1intrusive_1_1split__list_1_1expandable__bucket__table.html" title="Expandable bucket table.">intrusive::split_list::expandable_bucket_table</a>, <a class="el" href="classcds_1_1intrusive_1_1split__list_1_1static__bucket__table.html" title="Static bucket table.">intrusive::split_list::static_bucket_table</a> which selects by <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1dynamic__bucket__table.html" title="[value-option] Split-list dynamic bucket table option">intrusive::split_list::dynamic_bucket_table</a> option. </p>

</div>
</div>
<a class="anchor" id="a2ae45b7ca0c41055ef152d51c0de0519"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set.html">SplitListSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nItemCount</td><td>estimate average of item count </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor - average item count per bucket. Small integer up to 8, default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5b749193c0afb53019a23e55d056e30d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a set. </p>
<p>For empty set</p>
<div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5b749193c0afb53019a23e55d056e30d" title="Returns a forward iterator addressing the first element in a set.">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719" title="Returns an iterator that addresses the location succeeding the last element in a set.">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a158e36626a98950dfa704e56350f8c7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic) </p>
<p>The function unlink all items from the set. The function is not atomic and not lock-free and should be used for debugging only.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a28502e723c54f48822af1c0ac9abb3f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics. </dd></dl>

</div>
</div>
<a class="anchor" id="a235f570701db4f0827322fb22444ca81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then assume that the set is empty. Thus, the correct item counting feature is an important part of split-list set implementation. </p>

</div>
</div>
<a class="anchor" id="a730086ffb1a533f013ca86bd43d1d719"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a set. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the set. For empty set</p>
<div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5b749193c0afb53019a23e55d056e30d" title="Returns a forward iterator addressing the first element in a set.">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719" title="Returns an iterator that addresses the location succeeding the last element in a set.">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afeeb455a97f72ee67e00309f285e7eae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>item</code> exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> should be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code> function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set. </p>

</div>
</div>
<a class="anchor" id="ac2d9d2591d87d680e1e0942e28a636e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_erase_val"></a> Since the key of <a class="el" href="classcds_1_1container_1_1_split_list_set.html" title="Split-ordered list set.">SplitListSet</a>'s item type <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The set item comparator should be able to compare the values of type <code>value_type</code> and the type <code>Q</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a0a2ad7d9963027c9f44c7a9e4bd7a2ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a> <span class="keyword">const</span>&amp; val) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Since the key of <a class="el" href="classcds_1_1container_1_1_split_list_set.html" title="Split-ordered list set.">SplitListSet</a>'s <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The list item comparator should be able to compare the values of the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="ac0813e79767faec8708232805e1e63e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ad8e77899f2784acde39124d511b47c53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="acc445527780ac40a2e8ad5dc480360f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a>&amp; item, Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor may modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function makes RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae346c1fd0810284b48045f910ec2c7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_find_cfunc"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function makes RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a9626b75ca1bc8166ecb059a53fa8b4db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_find_val"></a> The function searches the item with key equal to <code>val</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a>.</p>
<p>The function makes RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a027de11aa3784ac1d1fb52e1a3a88df4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a3ab3bbff0e1926afa920082c63819755"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a3a20895471bfcf2c99a076acab26bfd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a5426434330a53312429d8d721fb66cc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631">value_type</a>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4f6a97dd49c0995a3f761e57ab0533db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1urcu_1_1gc.html">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a13aa0c64fca19276721158ffe389d631" title="type of value stored in the list">value_type</a>&amp; val ) ;</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success. It may be passed by reference using <code>boost::ref</code></p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/split_list_set_rcu.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:37:58 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
