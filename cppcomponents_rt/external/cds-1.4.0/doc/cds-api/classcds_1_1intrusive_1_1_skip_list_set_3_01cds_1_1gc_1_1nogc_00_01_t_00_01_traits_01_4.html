<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>cds: cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html">SkipListSet< cds::gc::nogc, T, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__map.html">Sets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free skip-list set (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">gc::nogc</a>)  
 <a href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/skip_list_nogc.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.png" usemap="#cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt;_map" alt=""/>
  <map id="cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt;_map" name="cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt;_map">
<area href="classcds_1_1container_1_1_skip_list_set_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html" title="Lock-free skip-list set (template specialization for gc::nogc)" alt="cds::container::SkipListSet&lt; gc::nogc, T, Traits &gt;" shape="rect" coords="0,56,307,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a081517d52ee7e74c59735ac724f427a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081517d52ee7e74c59735ac724f427a3"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a></td></tr>
<tr class="memdesc:a081517d52ee7e74c59735ac724f427a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the skip-list <br/></td></tr>
<tr class="separator:a081517d52ee7e74c59735ac724f427a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d5a6064343f1dabfdad3c8541e6580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4d5a6064343f1dabfdad3c8541e6580"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ac4d5a6064343f1dabfdad3c8541e6580">options</a></td></tr>
<tr class="memdesc:ac4d5a6064343f1dabfdad3c8541e6580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:ac4d5a6064343f1dabfdad3c8541e6580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd923fd419e2cf218924211a7fff849"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dd923fd419e2cf218924211a7fff849"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a0dd923fd419e2cf218924211a7fff849">hook</a></td></tr>
<tr class="memdesc:a0dd923fd419e2cf218924211a7fff849"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:a0dd923fd419e2cf218924211a7fff849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba702b6e22bb2909a201dc62eb2030a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba702b6e22bb2909a201dc62eb2030a1"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#aba702b6e22bb2909a201dc62eb2030a1">node_type</a></td></tr>
<tr class="memdesc:aba702b6e22bb2909a201dc62eb2030a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:aba702b6e22bb2909a201dc62eb2030a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21507b523764197076d019570da7ae9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21507b523764197076d019570da7ae9"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ac21507b523764197076d019570da7ae9">key_comparator</a></td></tr>
<tr class="memdesc:ac21507b523764197076d019570da7ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparision functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:ac21507b523764197076d019570da7ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d7c080ec3d80775ddf591a9f4a80fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26d7c080ec3d80775ddf591a9f4a80fe"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#aba702b6e22bb2909a201dc62eb2030a1">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a0dd923fd419e2cf218924211a7fff849">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a26d7c080ec3d80775ddf591a9f4a80fe">node_traits</a></td></tr>
<tr class="memdesc:a26d7c080ec3d80775ddf591a9f4a80fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br/></td></tr>
<tr class="separator:a26d7c080ec3d80775ddf591a9f4a80fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e6b724de6a03802f4375d3ff44402"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a929e6b724de6a03802f4375d3ff44402"></a>
typedef <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a929e6b724de6a03802f4375d3ff44402">gc</a></td></tr>
<tr class="memdesc:a929e6b724de6a03802f4375d3ff44402"><td class="mdescLeft">&#160;</td><td class="mdescRight">No garbage collector is used. <br/></td></tr>
<tr class="separator:a929e6b724de6a03802f4375d3ff44402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496a0198d68e91f66e08a4ac995bfb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7496a0198d68e91f66e08a4ac995bfb9"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a7496a0198d68e91f66e08a4ac995bfb9">item_counter</a></td></tr>
<tr class="memdesc:a7496a0198d68e91f66e08a4ac995bfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a7496a0198d68e91f66e08a4ac995bfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e571e998cd45e5d1cbd6c5e42d64761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e571e998cd45e5d1cbd6c5e42d64761"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3e571e998cd45e5d1cbd6c5e42d64761">memory_model</a></td></tr>
<tr class="memdesc:a3e571e998cd45e5d1cbd6c5e42d64761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a3e571e998cd45e5d1cbd6c5e42d64761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8400003b08a2ca32a5682db5eb99a9b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8400003b08a2ca32a5682db5eb99a9b4"></a>
typedef <br class="typebreak"/>
options::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a8400003b08a2ca32a5682db5eb99a9b4">random_level_generator</a></td></tr>
<tr class="memdesc:a8400003b08a2ca32a5682db5eb99a9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br/></td></tr>
<tr class="separator:a8400003b08a2ca32a5682db5eb99a9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ec13734f17b2d62fbc4cb459171d5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12ec13734f17b2d62fbc4cb459171d5f"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a12ec13734f17b2d62fbc4cb459171d5f">allocator_type</a></td></tr>
<tr class="memdesc:a12ec13734f17b2d62fbc4cb459171d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining array of next pointers of the node <br/></td></tr>
<tr class="separator:a12ec13734f17b2d62fbc4cb459171d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afaef85880d5f87337d5c6ec536610d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afaef85880d5f87337d5c6ec536610d"></a>
typedef options::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a2afaef85880d5f87337d5c6ec536610d">back_off</a></td></tr>
<tr class="memdesc:a2afaef85880d5f87337d5c6ec536610d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off trategy. <br/></td></tr>
<tr class="separator:a2afaef85880d5f87337d5c6ec536610d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fe2972f4a60d472bd049eb44588ad6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8fe2972f4a60d472bd049eb44588ad6"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ae8fe2972f4a60d472bd049eb44588ad6">stat</a></td></tr>
<tr class="memdesc:ae8fe2972f4a60d472bd049eb44588ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:ae8fe2972f4a60d472bd049eb44588ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30065b937ec563d64800bd0f6e323694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30065b937ec563d64800bd0f6e323694"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a30065b937ec563d64800bd0f6e323694">disposer</a></td></tr>
<tr class="memdesc:a30065b937ec563d64800bd0f6e323694"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer used <br/></td></tr>
<tr class="separator:a30065b937ec563d64800bd0f6e323694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80419c0f22c3c2f74ccc1b02981b52c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80419c0f22c3c2f74ccc1b02981b52c3"></a>
typedef <br class="typebreak"/>
skip_list::details::iterator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a929e6b724de6a03802f4375d3ff44402">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a26d7c080ec3d80775ddf591a9f4a80fe">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a2afaef85880d5f87337d5c6ec536610d">back_off</a>, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3">iterator</a></td></tr>
<tr class="memdesc:a80419c0f22c3c2f74ccc1b02981b52c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. <br/></td></tr>
<tr class="separator:a80419c0f22c3c2f74ccc1b02981b52c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3475bb64b46fde4f67ee720f1511bee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3475bb64b46fde4f67ee720f1511bee7"></a>
typedef <br class="typebreak"/>
skip_list::details::iterator<br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a929e6b724de6a03802f4375d3ff44402">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a26d7c080ec3d80775ddf591a9f4a80fe">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a2afaef85880d5f87337d5c6ec536610d">back_off</a>, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3475bb64b46fde4f67ee720f1511bee7">const_iterator</a></td></tr>
<tr class="memdesc:a3475bb64b46fde4f67ee720f1511bee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br/></td></tr>
<tr class="separator:a3475bb64b46fde4f67ee720f1511bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13cdd35656e060eeb11ff746c13be2d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a13cdd35656e060eeb11ff746c13be2d5">SkipListSet</a> ()</td></tr>
<tr class="memdesc:a13cdd35656e060eeb11ff746c13be2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a13cdd35656e060eeb11ff746c13be2d5">More...</a><br/></td></tr>
<tr class="separator:a13cdd35656e060eeb11ff746c13be2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95f417f31d0852db66f13f7f8e8003a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95f417f31d0852db66f13f7f8e8003a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ac95f417f31d0852db66f13f7f8e8003a">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:ac95f417f31d0852db66f13f7f8e8003a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and destructs the skip-list. <br/></td></tr>
<tr class="separator:ac95f417f31d0852db66f13f7f8e8003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2479c387cae96e6f6b3198efac1b8a67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2479c387cae96e6f6b3198efac1b8a67"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a2479c387cae96e6f6b3198efac1b8a67">begin</a> ()</td></tr>
<tr class="memdesc:a2479c387cae96e6f6b3198efac1b8a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a2479c387cae96e6f6b3198efac1b8a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da0b25fc9b911d480a093be3ec8f9dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da0b25fc9b911d480a093be3ec8f9dc"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3da0b25fc9b911d480a093be3ec8f9dc">end</a> ()</td></tr>
<tr class="memdesc:a3da0b25fc9b911d480a093be3ec8f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:a3da0b25fc9b911d480a093be3ec8f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb8df3e289c57aca2126588543e28c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a2bb8df3e289c57aca2126588543e28c5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a2bb8df3e289c57aca2126588543e28c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a2bb8df3e289c57aca2126588543e28c5">More...</a><br/></td></tr>
<tr class="separator:a2bb8df3e289c57aca2126588543e28c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5210f73ad620468592e27b4c6d596"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:af2c5210f73ad620468592e27b4c6d596"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#af2c5210f73ad620468592e27b4c6d596">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:af2c5210f73ad620468592e27b4c6d596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the set.  <a href="#af2c5210f73ad620468592e27b4c6d596">More...</a><br/></td></tr>
<tr class="separator:af2c5210f73ad620468592e27b4c6d596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5a59babad5222da76744ce971a6616"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aac5a59babad5222da76744ce971a6616"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#aac5a59babad5222da76744ce971a6616">find</a> (Q &amp;val, Func f) const </td></tr>
<tr class="memdesc:aac5a59babad5222da76744ce971a6616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#aac5a59babad5222da76744ce971a6616">More...</a><br/></td></tr>
<tr class="separator:aac5a59babad5222da76744ce971a6616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913c33c4c217e3cdd7abdc88293c09c4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a913c33c4c217e3cdd7abdc88293c09c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a913c33c4c217e3cdd7abdc88293c09c4">find_with</a> (Q &amp;val, Less pred, Func f) const </td></tr>
<tr class="memdesc:a913c33c4c217e3cdd7abdc88293c09c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a913c33c4c217e3cdd7abdc88293c09c4">More...</a><br/></td></tr>
<tr class="separator:a913c33c4c217e3cdd7abdc88293c09c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945437ca340fbead265f94f18ee29425"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a945437ca340fbead265f94f18ee29425"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a945437ca340fbead265f94f18ee29425">find</a> (Q const &amp;val, Func f) const </td></tr>
<tr class="memdesc:a945437ca340fbead265f94f18ee29425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a945437ca340fbead265f94f18ee29425">More...</a><br/></td></tr>
<tr class="separator:a945437ca340fbead265f94f18ee29425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395120ca714d69751cb5d5a908e072a1"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a395120ca714d69751cb5d5a908e072a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a395120ca714d69751cb5d5a908e072a1">find_with</a> (Q const &amp;val, Less pred, Func f) const </td></tr>
<tr class="memdesc:a395120ca714d69751cb5d5a908e072a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a395120ca714d69751cb5d5a908e072a1">More...</a><br/></td></tr>
<tr class="separator:a395120ca714d69751cb5d5a908e072a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48610dd1f509dfa6feb76c0b5f70a141"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a48610dd1f509dfa6feb76c0b5f70a141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a48610dd1f509dfa6feb76c0b5f70a141">find</a> (Q const &amp;val) const </td></tr>
<tr class="memdesc:a48610dd1f509dfa6feb76c0b5f70a141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a48610dd1f509dfa6feb76c0b5f70a141">More...</a><br/></td></tr>
<tr class="separator:a48610dd1f509dfa6feb76c0b5f70a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ddca0e562ab88aaa8392f2af0021aa"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a12ddca0e562ab88aaa8392f2af0021aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a12ddca0e562ab88aaa8392f2af0021aa">find_with</a> (Q const &amp;val, Less pred) const </td></tr>
<tr class="memdesc:a12ddca0e562ab88aaa8392f2af0021aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a12ddca0e562ab88aaa8392f2af0021aa">More...</a><br/></td></tr>
<tr class="separator:a12ddca0e562ab88aaa8392f2af0021aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1597b27a81ae5a90cdc73e2ed4bfdb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ab1597b27a81ae5a90cdc73e2ed4bfdb4">clear</a> ()</td></tr>
<tr class="memdesc:ab1597b27a81ae5a90cdc73e2ed4bfdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#ab1597b27a81ae5a90cdc73e2ed4bfdb4">More...</a><br/></td></tr>
<tr class="separator:ab1597b27a81ae5a90cdc73e2ed4bfdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbf58d8a2ed476f74bb7e77e2bc43dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#abbbf58d8a2ed476f74bb7e77e2bc43dc">size</a> () const </td></tr>
<tr class="memdesc:abbbf58d8a2ed476f74bb7e77e2bc43dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#abbbf58d8a2ed476f74bb7e77e2bc43dc">More...</a><br/></td></tr>
<tr class="separator:abbbf58d8a2ed476f74bb7e77e2bc43dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab946fdc635a590219b4ed987775bb991"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab946fdc635a590219b4ed987775bb991"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ab946fdc635a590219b4ed987775bb991">empty</a> () const </td></tr>
<tr class="memdesc:ab946fdc635a590219b4ed987775bb991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br/></td></tr>
<tr class="separator:ab946fdc635a590219b4ed987775bb991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae127cb1c5c32f9595a4b83e269c78d8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae127cb1c5c32f9595a4b83e269c78d8b"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ae8fe2972f4a60d472bd049eb44588ad6">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ae127cb1c5c32f9595a4b83e269c78d8b">statistics</a> () const </td></tr>
<tr class="memdesc:ae127cb1c5c32f9595a4b83e269c78d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:ae127cb1c5c32f9595a4b83e269c78d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3e2313ed70db7d031c16b787709823d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e2313ed70db7d031c16b787709823d0"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3475bb64b46fde4f67ee720f1511bee7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3e2313ed70db7d031c16b787709823d0">begin</a> () const </td></tr>
<tr class="memdesc:a3e2313ed70db7d031c16b787709823d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br/></td></tr>
<tr class="separator:a3e2313ed70db7d031c16b787709823d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddedebfa15589ca8a5861482ea01a09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ddedebfa15589ca8a5861482ea01a09"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3475bb64b46fde4f67ee720f1511bee7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> ()</td></tr>
<tr class="separator:a8ddedebfa15589ca8a5861482ea01a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0aeed1a467f5754acd5fa021a207db78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aeed1a467f5754acd5fa021a207db78"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3475bb64b46fde4f67ee720f1511bee7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a0aeed1a467f5754acd5fa021a207db78">end</a> () const </td></tr>
<tr class="memdesc:a0aeed1a467f5754acd5fa021a207db78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br/></td></tr>
<tr class="separator:a0aeed1a467f5754acd5fa021a207db78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f622816c9cd023f70c693fc708a42d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f622816c9cd023f70c693fc708a42d9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3475bb64b46fde4f67ee720f1511bee7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> ()</td></tr>
<tr class="separator:a7f622816c9cd023f70c693fc708a42d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ae0cc18cef6852d51f842832e58a8a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae0cc18cef6852d51f842832e58a8a7"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a1ae0cc18cef6852d51f842832e58a8a7">max_height</a> () noexcept()</td></tr>
<tr class="memdesc:a1ae0cc18cef6852d51f842832e58a8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum height of skip-list. The max height is a constant for each object and does not exceed 32. <br/></td></tr>
<tr class="separator:a1ae0cc18cef6852d51f842832e58a8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6a04426b8a787c2014b0bdf055b94be8"><td class="memItemLeft" align="right" valign="top">static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a6a04426b8a787c2014b0bdf055b94be8">c_nMaxHeight</a></td></tr>
<tr class="memdesc:a6a04426b8a787c2014b0bdf055b94be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code>  <a href="#a6a04426b8a787c2014b0bdf055b94be8">More...</a><br/></td></tr>
<tr class="separator:a6a04426b8a787c2014b0bdf055b94be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a60a9e49d972f2e3d5085b432fbaac2f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60a9e49d972f2e3d5085b432fbaac2f6"></a>
typedef node_type::atomic_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a60a9e49d972f2e3d5085b432fbaac2f6">atomic_node_ptr</a></td></tr>
<tr class="memdesc:a60a9e49d972f2e3d5085b432fbaac2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic node pointer. <br/></td></tr>
<tr class="separator:a60a9e49d972f2e3d5085b432fbaac2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af1d1b8207606fa70ab21593b7e499670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1d1b8207606fa70ab21593b7e499670"></a>
head_node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#af1d1b8207606fa70ab21593b7e499670">m_Head</a></td></tr>
<tr class="memdesc:af1d1b8207606fa70ab21593b7e499670"><td class="mdescLeft">&#160;</td><td class="mdescRight">head tower (max height) <br/></td></tr>
<tr class="separator:af1d1b8207606fa70ab21593b7e499670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9447c9f33c76ea4f526f33a8bd2b41a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9447c9f33c76ea4f526f33a8bd2b41a9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a7496a0198d68e91f66e08a4ac995bfb9">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a9447c9f33c76ea4f526f33a8bd2b41a9">m_ItemCounter</a></td></tr>
<tr class="memdesc:a9447c9f33c76ea4f526f33a8bd2b41a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br/></td></tr>
<tr class="separator:a9447c9f33c76ea4f526f33a8bd2b41a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0033778ade3227ec0fdc0bc9eeb48ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0033778ade3227ec0fdc0bc9eeb48ff7"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a8400003b08a2ca32a5682db5eb99a9b4">random_level_generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a0033778ade3227ec0fdc0bc9eeb48ff7">m_RandomLevelGen</a></td></tr>
<tr class="memdesc:a0033778ade3227ec0fdc0bc9eeb48ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator instance <br/></td></tr>
<tr class="separator:a0033778ade3227ec0fdc0bc9eeb48ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb28c90b765594f4acd96f2f92744fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbb28c90b765594f4acd96f2f92744fb"></a>
std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#acbb28c90b765594f4acd96f2f92744fb">m_nHeight</a></td></tr>
<tr class="memdesc:acbb28c90b765594f4acd96f2f92744fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimated high level <br/></td></tr>
<tr class="separator:acbb28c90b765594f4acd96f2f92744fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21af593e331073f688343bb98c5a3a0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21af593e331073f688343bb98c5a3a0d"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ae8fe2972f4a60d472bd049eb44588ad6">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a21af593e331073f688343bb98c5a3a0d">m_Stat</a></td></tr>
<tr class="memdesc:a21af593e331073f688343bb98c5a3a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br/></td></tr>
<tr class="separator:a21af593e331073f688343bb98c5a3a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Traits = skip_list::type_traits&gt;<br/>
class cds::intrusive::SkipListSet&lt; cds::gc::nogc, T, Traits &gt;</h3>

<p>Lock-free skip-list set (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">gc::nogc</a>) </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_nogc"></a> This specialization is intended for so-called persistent usage when no item reclamation may be performed. The class does not support deleting of list item.</p>
<p>See <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#cds_intrusive_SkipListSet_hp">SkipListSet</a> for description of skip-list.</p>
<p><b>Template arguments</b> :</p>
<ul>
<li><code>T</code> - type to be stored in the set. The type must be based on <a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node.">skip_list::node</a> (for <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1base__hook.html" title="Base hook.">skip_list::base_hook</a>) or it must have a member of type <a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node.">skip_list::node</a> (for <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1member__hook.html" title="Member hook.">skip_list::member_hook</a>).</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1type__traits.html" title="Type traits for SkipListSet class.">skip_list::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based list with <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits.">cds::intrusive::skip_list::make_traits</a> metafunction istead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits.">cds::intrusive::skip_list::make_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1intrusive_1_1opt_1_1hook.html" title="Hook option.">opt::hook</a> - hook used. Possible values are: <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1base__hook.html" title="Base hook.">skip_list::base_hook</a>, <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1member__hook.html" title="Member hook.">skip_list::member_hook</a>, <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1traits__hook.html" title="Traits hook.">skip_list::traits_hook</a>. If the option is not specified, <code>skip_list::base_hook&lt;&gt;</code> and <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a> - key comparison functor. No default functor is provided. If the option is not specified, the <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a> - specifies binary predicate used for key comparision. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a> that is no item counting.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model.">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model.">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1random__level__generator.html" title="Option specifying random level generator.">skip_list::random_level_generator</a> - random level generator. Can be <a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1xorshift.html" title="Xor-shift random level generator.">skip_list::xorshift</a>, <a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1turbo__pascal.html" title="Turbo-pascal random level generator.">skip_list::turbo_pascal</a> or user-provided one. See <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1random__level__generator.html" title="Option specifying random level generator.">skip_list::random_level_generator</a> option description for explanation. Default is <code>skip_list::turbo_pascal</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - although the skip-list is an intrusive container, an allocator should be provided to maintain variable randomly-calculated height of the node since the node can contain up to 32 next pointers. The allocator option is used to allocate an array of next pointers for nodes which height is more than 1. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1back__off.html" title="[type-option] Back-off strategy option setter">opt::back_off</a> - back-off strategy used. If the option is not specified, the <a class="el" href="namespacecds_1_1backoff.html#a6d7bf77f149436d5d587a2ec841e5044" title="Default backoff strategy.">cds::backoff::Default</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs">opt::stat</a> - internal statistics. Available types: <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1stat.html" title="SkipListSet internal statistics.">skip_list::stat</a>, <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1empty__stat.html" title="SkipListSet empty internal statistics.">skip_list::empty_stat</a> (the default)</li>
<li><a class="el" href="structcds_1_1intrusive_1_1opt_1_1disposer.html" title="Item disposer option setter.">opt::disposer</a> - the functor used for dispose removed items. Default is <a class="el" href="structcds_1_1intrusive_1_1opt_1_1v_1_1empty__disposer.html" title="Empty item disposer.">opt::v::empty_disposer</a>. The disposer is used only in object destructor and in <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ab1597b27a81ae5a90cdc73e2ed4bfdb4">clear</a> function.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3">iterator</a> and <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3475bb64b46fde4f67ee720f1511bee7">const_iterator</a>). The iteration is ordered.</p>
<p>The iterator class supports the following minimalistic interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a>( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a> <span class="keyword">const</span>&amp; s) ;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3" title="type of value stored in the skip-list">value_type</a> * operator -&gt;() <span class="keyword">const</span> ;</div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3" title="type of value stored in the skip-list">value_type</a>&amp; operator *() <span class="keyword">const</span> ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a>&amp; operator ++() ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a>&amp; src) ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a80419c0f22c3c2f74ccc1b02981b52c3" title="Iterator type.">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span> ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a3da0b25fc9b911d480a093be3ec8f9dc">end</a>, <code>cend</code> member functions points to <code>NULL</code> and should not be dereferenced.</p>
<p><b>How to use</b></p>
<p>You should incorporate <a class="el" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node.">skip_list::node</a> into your struct <code>T</code> and provide appropriate <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1type__traits.html#a48a22420883b7b496c2b244da0d09d77" title="Hook used.">skip_list::type_traits::hook</a> in your <code>Traits</code> template parameters. Usually, for <code>Traits</code> you define a struct based on <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1type__traits.html" title="Type traits for SkipListSet class.">skip_list::type_traits</a>.</p>
<p>Example for base hook: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/skip_list_nogc.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Data stored in skip list</span></div>
<div class="line"><span class="keyword">struct </span>my_data: <span class="keyword">public</span> <a class="code" href="classcds_1_1intrusive_1_1skip__list_1_1node.html" title="Skip list node.">cds::intrusive::skip_list::node</a>&lt; cds::gc::nogc &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// key field</span></div>
<div class="line">    std::string     strKey  ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// other data</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// my_data compare functor</span></div>
<div class="line"><span class="keyword">struct </span>my_data_cmp {</div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey )   ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s)   ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey )    ;</div>
<div class="line">    }</div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type_traits</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1type__traits.html" title="Type traits for SkipListSet class.">cds::intrusive::skip_list::type_traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1base__hook.html" title="Base hook.">cds::intrusive::skip_list::base_hook&lt; cds::opt::gc&lt; cds::gc::nogc &gt;</a> &gt;   <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a0dd923fd419e2cf218924211a7fff849" title="hook type">hook</a>    ;</div>
<div class="line">    <span class="keyword">typedef</span> my_data_cmp compare ;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare skip-list set type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set.html" title="Lock-free skip-list set.">cds::intrusive::SkipListSet&lt; cds::gc::nogc, my_data, my_traits &gt;</a>     traits_based_set   ;</div>
</div><!-- fragment --><p>Equivalent option-based code: </p>
<div class="fragment"><div class="line"><span class="comment">// GC-related specialization</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/skip_list_nogc.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_data {</div>
<div class="line">    <span class="comment">// see above</span></div>
<div class="line">}   ;</div>
<div class="line"><span class="keyword">struct </span>compare {</div>
<div class="line">    <span class="comment">// see above</span></div>
<div class="line">}   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare option-based skip-list set</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set.html" title="Lock-free skip-list set.">cds::intrusive::SkipListSet</a>&lt; <a class="code" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">cds::gc::nogc</a></div>
<div class="line">    ,my_data</div>
<div class="line">    , <span class="keyword">typename</span> <a class="code" href="structcds_1_1intrusive_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits.">cds::intrusive::skip_list::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1intrusive_1_1opt_1_1hook.html" title="Hook option.">cds::intrusive::opt::hook&lt; cds::intrusive::skip_list::base_hook&lt; cds::opt::gc&lt; cds::gc::nogc &gt;</a> &gt; &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::intrusive::opt::compare&lt; my_data_cmp &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; option_based_set   ;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13cdd35656e060eeb11ff746c13be2d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">SkipListSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The constructor checks whether the count of guards is enough for skip-list and may raise an exception if not. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab1597b27a81ae5a90cdc73e2ed4bfdb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic) </p>
<p>The function is not atomic. Finding and/or inserting is prohibited while clearing. Otherwise an unpredictable result may be encountered. Thus, <code><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ab1597b27a81ae5a90cdc73e2ed4bfdb4" title="Clears the set (non-atomic)">clear()</a></code> may be used only for debugging purposes. </p>

</div>
</div>
<a class="anchor" id="af2c5210f73ad620468592e27b4c6d596"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>val</code> exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> is not found in the set, then <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with item found. The functor signature is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3" title="type of value stored in the skip-list">value_type</a>&amp; item, <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3" title="type of value stored in the skip-list">value_type</a>&amp; val ) ;</div>
</div><!-- fragment --><p> with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code> function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refer to the same thing.</li>
</ul>
<p>The functor can change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You can pass <code>func</code> argument by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set. </p>

</div>
</div>
<a class="anchor" id="aac5a59babad5222da76744ce971a6616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code>. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_nogc_find_func"></a>The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3" title="type of value stored in the skip-list">value_type</a>&amp; item, Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You can pass <code>f</code> argument by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor can change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a945437ca340fbead265f94f18ee29425"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code>. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_nogc_find_cfunc"></a>The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3" title="type of value stored in the skip-list">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You can pass <code>f</code> argument by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor can change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a48610dd1f509dfa6feb76c0b5f70a141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code>. </p>
<p><a class="anchor" id="cds_intrusive_SkipListSet_nogc_find_val"></a>The function searches the item with key equal to <code>val</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a class="anchor" id="a913c33c4c217e3cdd7abdc88293c09c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_nogc_find_func">find(Q&amp;, Func)</a> but <code>pred</code> predicate is used for key compare. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a395120ca714d69751cb5d5a908e072a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_nogc_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> predicate is used for key compare. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a12ddca0e562ab88aaa8392f2af0021aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#cds_intrusive_SkipListSet_nogc_find_val">find(Q const&amp;)</a> but <code>pred</code> predicate is used for key compare. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a2bb8df3e289c57aca2126588543e28c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#a081517d52ee7e74c59735ac724f427a3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the set if it does not contain an item with key equal to <code>val</code>.</p>
<p>Returns <code>true</code> if <code>val</code> is placed into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="abbbf58d8a2ed476f74bb7e77e2bc43dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set. </p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter.">atomicity::empty_item_counter</a> this function always returns 0. The function is not suitable for checking the set emptiness, use <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#ab946fdc635a590219b4ed987775bb991">empty</a> member function for this purpose. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a6a04426b8a787c2014b0bdf055b94be8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = skip_list::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int const <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet</a>&lt; <a class="el" href="classcds_1_1gc_1_1nogc.html">cds::gc::nogc</a>, T, Traits &gt;::c_nMaxHeight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::conditional&lt;</div>
<div class="line">            (random_level_generator::c_nUpperBound &lt;= <a class="code" href="namespacecds_1_1intrusive_1_1skip__list.html#ada3b652d0f9a65b38dcd7697cb06c9e6" title="The maximum possible height of any skip-list.">skip_list::c_nHeightLimit</a>),</div>
<div class="line">            std::integral_constant&lt; unsigned int, random_level_generator::c_nUpperBound &gt;,</div>
<div class="line">            std::integral_constant&lt; unsigned int, skip_list::c_nHeightLimit &gt;</div>
<div class="line">        &gt;::type::value</div>
</div><!-- fragment -->
<p>Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code> </p>
<p>The max height is specified by <a class="el" href="structcds_1_1intrusive_1_1skip__list_1_1random__level__generator.html">random level generator</a> constant <code>m_nUpperBound</code> but it should be no more than 32 (<a class="el" href="namespacecds_1_1intrusive_1_1skip__list.html#ada3b652d0f9a65b38dcd7697cb06c9e6">skip_list::c_nHeightLimit</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/skip_list_nogc.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.4.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon May 20 2013 00:38:00 by Doxygen 1.8.3.1</i>
		</div>
	</BODY>
</HTML>
